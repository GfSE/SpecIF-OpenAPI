/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * SpecIF Web API
 * Web API for the Specification Integration Facility (SpecIF).
 *
 * OpenAPI spec version: v1.1
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "/".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface HttpStatusDetails
 */
export interface HttpStatusDetails extends null<String, ModelObject> {
    [key: string]: ModelObject;

}
/**
 * 
 * @export
 * @interface ProjectDescriptor
 */
export interface ProjectDescriptor {
    /**
     * 
     * @type {SpecifMetaSchema}
     * @memberof ProjectDescriptor
     */
    schema: SpecifMetaSchema;
    /**
     * 
     * @type {SpecifId}
     * @memberof ProjectDescriptor
     */
    id: SpecifId;
    /**
     * 
     * @type {SpecifRevision}
     * @memberof ProjectDescriptor
     */
    revision?: SpecifRevision;
    /**
     * 
     * @type {Array<SpecifMultiLanguageText>}
     * @memberof ProjectDescriptor
     */
    title?: Array<SpecifMultiLanguageText>;
    /**
     * 
     * @type {Array<SpecifMultiLanguageText>}
     * @memberof ProjectDescriptor
     */
    description?: Array<SpecifMultiLanguageText>;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectDescriptor
     */
    isExtension?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProjectDescriptor
     */
    generator?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectDescriptor
     */
    generatorVersion?: string;
    /**
     * 
     * @type {SpecifRights}
     * @memberof ProjectDescriptor
     */
    rights?: SpecifRights;
    /**
     * 
     * @type {SpecifDateTime}
     * @memberof ProjectDescriptor
     */
    createdAt?: SpecifDateTime;
    /**
     * 
     * @type {SpecifCreatedBy}
     * @memberof ProjectDescriptor
     */
    createdBy?: SpecifCreatedBy;
    /**
     * 
     * @type {SpecifNodes}
     * @memberof ProjectDescriptor
     */
    hierarchies: SpecifNodes;
}
/**
 * 
 * @export
 * @interface SpecIF
 */
export interface SpecIF {
    /**
     * 
     * @type {SpecifMetaSchema}
     * @memberof SpecIF
     */
    schema: SpecifMetaSchema;
    /**
     * 
     * @type {SpecifId}
     * @memberof SpecIF
     */
    id: SpecifId;
    /**
     * 
     * @type {SpecifRevision}
     * @memberof SpecIF
     */
    revision?: SpecifRevision;
    /**
     * 
     * @type {Array<SpecifMultiLanguageText>}
     * @memberof SpecIF
     */
    title?: Array<SpecifMultiLanguageText>;
    /**
     * 
     * @type {Array<SpecifMultiLanguageText>}
     * @memberof SpecIF
     */
    description?: Array<SpecifMultiLanguageText>;
    /**
     * 
     * @type {boolean}
     * @memberof SpecIF
     */
    isExtension?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SpecIF
     */
    generator?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecIF
     */
    generatorVersion?: string;
    /**
     * 
     * @type {SpecifRights}
     * @memberof SpecIF
     */
    rights?: SpecifRights;
    /**
     * 
     * @type {SpecifDateTime}
     * @memberof SpecIF
     */
    createdAt?: SpecifDateTime;
    /**
     * 
     * @type {SpecifCreatedBy}
     * @memberof SpecIF
     */
    createdBy?: SpecifCreatedBy;
    /**
     * 
     * @type {Array<SpecifDataType>}
     * @memberof SpecIF
     */
    dataTypes: Array<SpecifDataType>;
    /**
     * 
     * @type {Array<SpecifPropertyClass>}
     * @memberof SpecIF
     */
    propertyClasses: Array<SpecifPropertyClass>;
    /**
     * 
     * @type {Array<SpecifResourceClass>}
     * @memberof SpecIF
     */
    resourceClasses: Array<SpecifResourceClass>;
    /**
     * 
     * @type {Array<SpecifStatementClass>}
     * @memberof SpecIF
     */
    statementClasses: Array<SpecifStatementClass>;
    /**
     * 
     * @type {Array<SpecifResource>}
     * @memberof SpecIF
     */
    resources: Array<SpecifResource>;
    /**
     * 
     * @type {Array<SpecifStatement>}
     * @memberof SpecIF
     */
    statements: Array<SpecifStatement>;
    /**
     * 
     * @type {SpecifNodes}
     * @memberof SpecIF
     */
    hierarchies: SpecifNodes;
    /**
     * 
     * @type {Array<SpecifFile>}
     * @memberof SpecIF
     */
    files?: Array<SpecifFile>;
}
/**
 * A list of pointers to resources resp. statements which have been merged to this one.
 * @export
 * @interface SpecifAlternativeId
 */
export interface SpecifAlternativeId {
    /**
     * 
     * @type {SpecifId}
     * @memberof SpecifAlternativeId
     */
    id: SpecifId;
    /**
     * 
     * @type {SpecifRevision}
     * @memberof SpecifAlternativeId
     */
    revision?: SpecifRevision;
    /**
     * 
     * @type {SpecifId}
     * @memberof SpecifAlternativeId
     */
    project?: SpecifId;
}
/**
 * The list of consolidated items to be used in case a consolidated item shall be updated.
 * @export
 */
export type SpecifAlternativeIds = Array<SpecifAlternativeId>
/**
 * The creator of the SpecIF data-set (file). If specified, at least an e-mail address must be given.
 * @export
 * @interface SpecifCreatedBy
 */
export interface SpecifCreatedBy {
    /**
     * 
     * @type {string}
     * @memberof SpecifCreatedBy
     */
    familyName?: string;
    /**
     * 
     * @type {string}
     * @memberof SpecifCreatedBy
     */
    givenName?: string;
    /**
     * 
     * @type {SpecifOrg}
     * @memberof SpecifCreatedBy
     */
    org?: SpecifOrg;
    /**
     * 
     * @type {string}
     * @memberof SpecifCreatedBy
     */
    email: string;
}
/**
 * 
 * @export
 * @interface SpecifDataType
 */
export interface SpecifDataType {
    /**
     * 
     * @type {SpecifId}
     * @memberof SpecifDataType
     */
    id: SpecifId;
    /**
     * 
     * @type {SpecifText}
     * @memberof SpecifDataType
     */
    title: SpecifText;
    /**
     * 
     * @type {SpecifMultiLanguageText}
     * @memberof SpecifDataType
     */
    description?: SpecifMultiLanguageText;
    /**
     * 
     * @type {SpecifRevision}
     * @memberof SpecifDataType
     */
    revision?: SpecifRevision;
    /**
     * 
     * @type {SpecifReplaces}
     * @memberof SpecifDataType
     */
    replaces?: SpecifReplaces;
    /**
     * 
     * @type {string}
     * @memberof SpecifDataType
     */
    type: SpecifDataType.TypeEnum;
    /**
     * 
     * @type {number}
     * @memberof SpecifDataType
     */
    maxLength?: number;
    /**
     * 
     * @type {number}
     * @memberof SpecifDataType
     */
    fractionDigits?: number;
    /**
     * 
     * @type {number}
     * @memberof SpecifDataType
     */
    minInclusive?: number;
    /**
     * 
     * @type {number}
     * @memberof SpecifDataType
     */
    maxInclusive?: number;
    /**
     * 
     * @type {SpecifEnumeratedValues}
     * @memberof SpecifDataType
     */
    enumeration?: SpecifEnumeratedValues;
    /**
     * 
     * @type {boolean}
     * @memberof SpecifDataType
     */
    multiple?: boolean;
    /**
     * 
     * @type {SpecifDateTime}
     * @memberof SpecifDataType
     */
    changedAt: SpecifDateTime;
    /**
     * 
     * @type {string}
     * @memberof SpecifDataType
     */
    changedBy?: string;
}

/**
 * @export
 * @namespace SpecifDataType
 */
export namespace SpecifDataType {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Boolean = <any> 'xs:boolean',
        Integer = <any> 'xs:integer',
        Double = <any> 'xs:double',
        AnyUri = <any> 'xs:anyUri',
        DateTime = <any> 'xs:dateTime',
        Duration = <any> 'xs:duration',
        String = <any> 'xs:string'
    }
}
/**
 * An ISO-8601 dateTime string. For reduced accuracy, any number of values may be dropped, but only from right to left.
 * @export
 */
export type SpecifDateTime = Date
/**
 * 
 * @export
 * @interface SpecifEnumeratedValue
 */
export interface SpecifEnumeratedValue {
    /**
     * 
     * @type {SpecifId}
     * @memberof SpecifEnumeratedValue
     */
    id: SpecifId;
    /**
     * 
     * @type {SpecifValue}
     * @memberof SpecifEnumeratedValue
     */
    value: SpecifValue;
}
/**
 * Enumerated values for the given dataType. If 'multiple' is true 0..n options may be selected, otherwise exactly one must be selected.
 * @export
 */
export type SpecifEnumeratedValues = Array<SpecifEnumeratedValue>
/**
 * 
 * @export
 * @interface SpecifFile
 */
export interface SpecifFile {
    /**
     * 
     * @type {SpecifId}
     * @memberof SpecifFile
     */
    id: SpecifId;
    /**
     * 
     * @type {SpecifText}
     * @memberof SpecifFile
     */
    title: SpecifText;
    /**
     * 
     * @type {SpecifMultiLanguageText}
     * @memberof SpecifFile
     */
    description?: SpecifMultiLanguageText;
    /**
     * An absolute or relative URL to the file; will be of format 'uri-reference' in future. If missing, the title applies.
     * @type {string}
     * @memberof SpecifFile
     */
    url?: string;
    /**
     * The file's media type (formerly MIME-type) according to https://www.iana.org/assignments/media-types/media-types.xhtml.
     * @type {string}
     * @memberof SpecifFile
     */
    type: string;
    /**
     * 
     * @type {SpecifRevision}
     * @memberof SpecifFile
     */
    revision?: SpecifRevision;
    /**
     * 
     * @type {SpecifReplaces}
     * @memberof SpecifFile
     */
    replaces?: SpecifReplaces;
    /**
     * 
     * @type {SpecifDateTime}
     * @memberof SpecifFile
     */
    changedAt: SpecifDateTime;
    /**
     * 
     * @type {string}
     * @memberof SpecifFile
     */
    changedBy?: string;
}
/**
 * The number of hierarchy levels.
 * @export
 */
export type SpecifHierarchyDepth = number
/**
 * A symbol for display as a prefix to titles; applicable to all instances of the class. Is usually a XML-encoded UTF-8 symbol, can be an URL or dataURL.
 * @export
 */
export type SpecifIcon = string
/**
 * A globally unique identifier.
 * @export
 */
export type SpecifId = string
/**
 * 
 * @export
 */
export type SpecifInstantiation = Array<string>
/**
 * A key for a particular revision of an identifiable item, e.g. of a resource. A key consists of a globally unique identifier and a revision. No or an undefined revision means the latest revision of the identified item.
 * @export
 * @interface SpecifKey
 */
export interface SpecifKey {
    /**
     * 
     * @type {SpecifId}
     * @memberof SpecifKey
     */
    id: SpecifId;
    /**
     * 
     * @type {SpecifRevision}
     * @memberof SpecifKey
     */
    revision?: SpecifRevision;
}
/**
 * A list of keys referencing items such as propertyClasses, resourceClasses or statementClasses; any list must have >0 entries including those of any parent element.
 * @export
 */
export type SpecifKeys = Array<SpecifKey>
/**
 * 
 * @export
 */
export type SpecifMetaSchema = string
/**
 * 
 * @export
 * @interface SpecifMultiLanguageText
 */
export interface SpecifMultiLanguageText {
    /**
     * 
     * @type {SpecifText}
     * @memberof SpecifMultiLanguageText
     */
    text: SpecifText;
    /**
     * 
     * @type {SpecifTextFormat}
     * @memberof SpecifMultiLanguageText
     */
    format?: SpecifTextFormat;
    /**
     * 
     * @type {string}
     * @memberof SpecifMultiLanguageText
     */
    language?: string;
}
/**
 * 
 * @export
 * @interface SpecifNode
 */
export interface SpecifNode {
    /**
     * 
     * @type {SpecifId}
     * @memberof SpecifNode
     */
    id: SpecifId;
    /**
     * 
     * @type {SpecifMultiLanguageText}
     * @memberof SpecifNode
     */
    title?: SpecifMultiLanguageText;
    /**
     * 
     * @type {SpecifMultiLanguageText}
     * @memberof SpecifNode
     */
    description?: SpecifMultiLanguageText;
    /**
     * 
     * @type {SpecifKey}
     * @memberof SpecifNode
     */
    resource: SpecifKey;
    /**
     * 
     * @type {SpecifNodes}
     * @memberof SpecifNode
     */
    nodes?: SpecifNodes;
    /**
     * 
     * @type {SpecifRevision}
     * @memberof SpecifNode
     */
    revision?: SpecifRevision;
    /**
     * 
     * @type {SpecifReplaces}
     * @memberof SpecifNode
     */
    replaces?: SpecifReplaces;
    /**
     * 
     * @type {SpecifDateTime}
     * @memberof SpecifNode
     */
    changedAt: SpecifDateTime;
    /**
     * 
     * @type {string}
     * @memberof SpecifNode
     */
    changedBy?: string;
}
/**
 * A list of pointers to resources; may be nested forming a tree, i.e. a hierarchy of pointers.
 * @export
 */
export type SpecifNodes = Array<DefinitionsSpecifNode>
/**
 * 
 * @export
 * @interface SpecifOrg
 */
export interface SpecifOrg {
    /**
     * 
     * @type {string}
     * @memberof SpecifOrg
     */
    organizationName: string;
}
/**
 * 
 * @export
 * @interface SpecifProperty
 */
export interface SpecifProperty {
    /**
     * 
     * @type {SpecifKey}
     * @memberof SpecifProperty
     */
    _class: SpecifKey;
    /**
     * 
     * @type {SpecifValues}
     * @memberof SpecifProperty
     */
    values: SpecifValues;
}
/**
 * 
 * @export
 * @interface SpecifPropertyClass
 */
export interface SpecifPropertyClass {
    /**
     * 
     * @type {SpecifId}
     * @memberof SpecifPropertyClass
     */
    id: SpecifId;
    /**
     * 
     * @type {SpecifText}
     * @memberof SpecifPropertyClass
     */
    title: SpecifText;
    /**
     * 
     * @type {SpecifMultiLanguageText}
     * @memberof SpecifPropertyClass
     */
    description?: SpecifMultiLanguageText;
    /**
     * 
     * @type {SpecifKey}
     * @memberof SpecifPropertyClass
     */
    dataType: SpecifKey;
    /**
     * 
     * @type {boolean}
     * @memberof SpecifPropertyClass
     */
    multiple?: boolean;
    /**
     * 
     * @type {SpecifValues}
     * @memberof SpecifPropertyClass
     */
    values?: SpecifValues;
    /**
     * 
     * @type {SpecifTextFormat}
     * @memberof SpecifPropertyClass
     */
    format?: SpecifTextFormat;
    /**
     * 
     * @type {string}
     * @memberof SpecifPropertyClass
     */
    unit?: string;
    /**
     * 
     * @type {SpecifRevision}
     * @memberof SpecifPropertyClass
     */
    revision?: SpecifRevision;
    /**
     * 
     * @type {SpecifReplaces}
     * @memberof SpecifPropertyClass
     */
    replaces?: SpecifReplaces;
    /**
     * 
     * @type {SpecifDateTime}
     * @memberof SpecifPropertyClass
     */
    changedAt: SpecifDateTime;
    /**
     * 
     * @type {string}
     * @memberof SpecifPropertyClass
     */
    changedBy?: string;
}
/**
 * For change and configuration management; the first revision has 0 entries, a simple modification has 1 entry and the result of a merge has 2 entries.
 * @export
 */
export type SpecifReplaces = Array<SpecifRevision>
/**
 * 
 * @export
 * @interface SpecifResource
 */
export interface SpecifResource {
    /**
     * 
     * @type {SpecifId}
     * @memberof SpecifResource
     */
    id: SpecifId;
    /**
     * 
     * @type {SpecifAlternativeIds}
     * @memberof SpecifResource
     */
    alternativeIds?: SpecifAlternativeIds;
    /**
     * 
     * @type {SpecifKey}
     * @memberof SpecifResource
     */
    _class: SpecifKey;
    /**
     * 
     * @type {string}
     * @memberof SpecifResource
     */
    language?: string;
    /**
     * 
     * @type {Array<SpecifProperty>}
     * @memberof SpecifResource
     */
    properties: Array<SpecifProperty>;
    /**
     * 
     * @type {SpecifRevision}
     * @memberof SpecifResource
     */
    revision?: SpecifRevision;
    /**
     * 
     * @type {SpecifReplaces}
     * @memberof SpecifResource
     */
    replaces?: SpecifReplaces;
    /**
     * 
     * @type {SpecifDateTime}
     * @memberof SpecifResource
     */
    changedAt: SpecifDateTime;
    /**
     * 
     * @type {string}
     * @memberof SpecifResource
     */
    changedBy?: string;
}
/**
 * 
 * @export
 * @interface SpecifResourceClass
 */
export interface SpecifResourceClass {
    /**
     * 
     * @type {SpecifId}
     * @memberof SpecifResourceClass
     */
    id: SpecifId;
    /**
     * 
     * @type {SpecifText}
     * @memberof SpecifResourceClass
     */
    title: SpecifText;
    /**
     * 
     * @type {SpecifMultiLanguageText}
     * @memberof SpecifResourceClass
     */
    description?: SpecifMultiLanguageText;
    /**
     * 
     * @type {SpecifKey}
     * @memberof SpecifResourceClass
     */
    _extends?: SpecifKey;
    /**
     * 
     * @type {SpecifIcon}
     * @memberof SpecifResourceClass
     */
    icon?: SpecifIcon;
    /**
     * 
     * @type {boolean}
     * @memberof SpecifResourceClass
     */
    isHeading?: boolean;
    /**
     * 
     * @type {SpecifInstantiation}
     * @memberof SpecifResourceClass
     */
    instantiation?: SpecifInstantiation;
    /**
     * 
     * @type {SpecifKeys}
     * @memberof SpecifResourceClass
     */
    propertyClasses: SpecifKeys;
    /**
     * 
     * @type {SpecifRevision}
     * @memberof SpecifResourceClass
     */
    revision?: SpecifRevision;
    /**
     * 
     * @type {SpecifReplaces}
     * @memberof SpecifResourceClass
     */
    replaces?: SpecifReplaces;
    /**
     * 
     * @type {SpecifDateTime}
     * @memberof SpecifResourceClass
     */
    changedAt: SpecifDateTime;
    /**
     * 
     * @type {string}
     * @memberof SpecifResourceClass
     */
    changedBy?: string;
}
/**
 * A globally unique revision tag with one or multiple blocks with alphanumeric characters separated by a special character [.:,;/-]. Sequential as well as branching/merging notations are possible.
 * @export
 */
export type SpecifRevision = string
/**
 * 
 * @export
 * @interface SpecifRights
 */
export interface SpecifRights {
    /**
     * 
     * @type {string}
     * @memberof SpecifRights
     */
    title: string;
    /**
     * 
     * @type {string}
     * @memberof SpecifRights
     */
    url: string;
}
/**
 * 
 * @export
 * @interface SpecifStatement
 */
export interface SpecifStatement {
    /**
     * 
     * @type {SpecifId}
     * @memberof SpecifStatement
     */
    id: SpecifId;
    /**
     * 
     * @type {SpecifAlternativeIds}
     * @memberof SpecifStatement
     */
    alternativeIds?: SpecifAlternativeIds;
    /**
     * 
     * @type {SpecifKey}
     * @memberof SpecifStatement
     */
    _class: SpecifKey;
    /**
     * 
     * @type {string}
     * @memberof SpecifStatement
     */
    language?: string;
    /**
     * If there is no title property, the statementClass' title applies.
     * @type {Array<SpecifProperty>}
     * @memberof SpecifStatement
     */
    properties?: Array<SpecifProperty>;
    /**
     * 
     * @type {SpecifKey}
     * @memberof SpecifStatement
     */
    subject: SpecifKey;
    /**
     * 
     * @type {SpecifKey}
     * @memberof SpecifStatement
     */
    object: SpecifKey;
    /**
     * 
     * @type {SpecifRevision}
     * @memberof SpecifStatement
     */
    revision?: SpecifRevision;
    /**
     * 
     * @type {SpecifReplaces}
     * @memberof SpecifStatement
     */
    replaces?: SpecifReplaces;
    /**
     * 
     * @type {SpecifDateTime}
     * @memberof SpecifStatement
     */
    changedAt: SpecifDateTime;
    /**
     * 
     * @type {string}
     * @memberof SpecifStatement
     */
    changedBy?: string;
}
/**
 * 
 * @export
 * @interface SpecifStatementClass
 */
export interface SpecifStatementClass {
    /**
     * 
     * @type {SpecifId}
     * @memberof SpecifStatementClass
     */
    id: SpecifId;
    /**
     * 
     * @type {SpecifText}
     * @memberof SpecifStatementClass
     */
    title: SpecifText;
    /**
     * 
     * @type {SpecifMultiLanguageText}
     * @memberof SpecifStatementClass
     */
    description?: SpecifMultiLanguageText;
    /**
     * 
     * @type {SpecifKey}
     * @memberof SpecifStatementClass
     */
    _extends?: SpecifKey;
    /**
     * 
     * @type {SpecifIcon}
     * @memberof SpecifStatementClass
     */
    icon?: SpecifIcon;
    /**
     * 
     * @type {SpecifInstantiation}
     * @memberof SpecifStatementClass
     */
    instantiation?: SpecifInstantiation;
    /**
     * 
     * @type {boolean}
     * @memberof SpecifStatementClass
     */
    isUndirected?: boolean;
    /**
     * 
     * @type {SpecifKeys}
     * @memberof SpecifStatementClass
     */
    propertyClasses?: SpecifKeys;
    /**
     * 
     * @type {SpecifKeys}
     * @memberof SpecifStatementClass
     */
    subjectClasses?: SpecifKeys;
    /**
     * 
     * @type {SpecifKeys}
     * @memberof SpecifStatementClass
     */
    objectClasses?: SpecifKeys;
    /**
     * 
     * @type {SpecifRevision}
     * @memberof SpecifStatementClass
     */
    revision?: SpecifRevision;
    /**
     * 
     * @type {SpecifReplaces}
     * @memberof SpecifStatementClass
     */
    replaces?: SpecifReplaces;
    /**
     * 
     * @type {SpecifDateTime}
     * @memberof SpecifStatementClass
     */
    changedAt: SpecifDateTime;
    /**
     * 
     * @type {string}
     * @memberof SpecifStatementClass
     */
    changedBy?: string;
}
/**
 * 
 * @export
 */
export type SpecifText = string
/**
 * 
 * @export
 * @enum {string}
 */
export enum SpecifTextFormat {
    Plain = <any> 'plain',
    Xhtml = <any> 'xhtml'
}
/**
 * First option for properties with dataType 'xs:string', second option for all others.
 * @export
 * @interface SpecifValue
 */
export interface SpecifValue {
}
/**
 * If 'multiple' of the propertyClass is undefined or false, the array must contain one item. If the value is unknown, omit the whole property. By default, the class' value applies.
 * @export
 */
export type SpecifValues = Array<SpecifValue>
/**
 * 
 * @export
 * @interface V11FilesBody
 */
export interface V11FilesBody {
    /**
     * 
     * @type {Blob}
     * @memberof V11FilesBody
     */
    file?: Blob;
}
/**
 * 
 * @export
 * @interface V11FilesBody1
 */
export interface V11FilesBody1 {
    /**
     * 
     * @type {Blob}
     * @memberof V11FilesBody1
     */
    file?: Blob;
}
/**
 * DataTypeApi - fetch parameter creator
 * @export
 */
export const DataTypeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all data types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesGet(options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/dataTypes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the data type; returns an error if there are referencing elements.
         * @param {SpecifId} id 
         * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesIdDelete(id: SpecifId, forced?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11DataTypesIdDelete.');
            }
            const localVarPath = `/specif/v1.1/dataTypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (forced !== undefined) {
                localVarQueryParameter['forced'] = forced;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the data type.
         * @param {SpecifId} id The data type ID.
         * @param {SpecifRevision} [revision] The data type revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesIdGet(id: SpecifId, revision?: SpecifRevision, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11DataTypesIdGet.');
            }
            const localVarPath = `/specif/v1.1/dataTypes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (revision !== undefined) {
                localVarQueryParameter['revision'] = revision;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all revisions of the data type.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesIdRevisionsGet(id: SpecifId, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11DataTypesIdRevisionsGet.');
            }
            const localVarPath = `/specif/v1.1/dataTypes/{id}/revisions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create the data type; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifDataType} [body] The data type to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesPost(body?: SpecifDataType, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/dataTypes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecifDataType" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the data type.
         * @param {SpecifDataType} [body] The data type to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesPut(body?: SpecifDataType, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/dataTypes`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecifDataType" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataTypeApi - functional programming interface
 * @export
 */
export const DataTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all data types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifDataType>> {
            const localVarFetchArgs = DataTypeApiFetchParamCreator(configuration).specifV11DataTypesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the data type; returns an error if there are referencing elements.
         * @param {SpecifId} id 
         * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesIdDelete(id: SpecifId, forced?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DataTypeApiFetchParamCreator(configuration).specifV11DataTypesIdDelete(id, forced, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the data type.
         * @param {SpecifId} id The data type ID.
         * @param {SpecifRevision} [revision] The data type revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpecifDataType> {
            const localVarFetchArgs = DataTypeApiFetchParamCreator(configuration).specifV11DataTypesIdGet(id, revision, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all revisions of the data type.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesIdRevisionsGet(id: SpecifId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifDataType>> {
            const localVarFetchArgs = DataTypeApiFetchParamCreator(configuration).specifV11DataTypesIdRevisionsGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create the data type; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifDataType} [body] The data type to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesPost(body?: SpecifDataType, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DataTypeApiFetchParamCreator(configuration).specifV11DataTypesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the data type.
         * @param {SpecifDataType} [body] The data type to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesPut(body?: SpecifDataType, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DataTypeApiFetchParamCreator(configuration).specifV11DataTypesPut(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DataTypeApi - factory interface
 * @export
 */
export const DataTypeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get all data types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesGet(options?: any) {
            return DataTypeApiFp(configuration).specifV11DataTypesGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the data type; returns an error if there are referencing elements.
         * @param {SpecifId} id 
         * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesIdDelete(id: SpecifId, forced?: boolean, options?: any) {
            return DataTypeApiFp(configuration).specifV11DataTypesIdDelete(id, forced, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the data type.
         * @param {SpecifId} id The data type ID.
         * @param {SpecifRevision} [revision] The data type revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any) {
            return DataTypeApiFp(configuration).specifV11DataTypesIdGet(id, revision, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all revisions of the data type.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesIdRevisionsGet(id: SpecifId, options?: any) {
            return DataTypeApiFp(configuration).specifV11DataTypesIdRevisionsGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create the data type; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifDataType} [body] The data type to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesPost(body?: SpecifDataType, options?: any) {
            return DataTypeApiFp(configuration).specifV11DataTypesPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the data type.
         * @param {SpecifDataType} [body] The data type to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11DataTypesPut(body?: SpecifDataType, options?: any) {
            return DataTypeApiFp(configuration).specifV11DataTypesPut(body, options)(fetch, basePath);
        },
    };
};

/**
 * DataTypeApi - object-oriented interface
 * @export
 * @class DataTypeApi
 * @extends {BaseAPI}
 */
export class DataTypeApi extends BaseAPI {
    /**
     * 
     * @summary Get all data types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public specifV11DataTypesGet(options?: any) {
        return DataTypeApiFp(this.configuration).specifV11DataTypesGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the data type; returns an error if there are referencing elements.
     * @param {SpecifId} id 
     * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public specifV11DataTypesIdDelete(id: SpecifId, forced?: boolean, options?: any) {
        return DataTypeApiFp(this.configuration).specifV11DataTypesIdDelete(id, forced, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the data type.
     * @param {SpecifId} id The data type ID.
     * @param {SpecifRevision} [revision] The data type revision; if missing the newest is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public specifV11DataTypesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any) {
        return DataTypeApiFp(this.configuration).specifV11DataTypesIdGet(id, revision, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all revisions of the data type.
     * @param {SpecifId} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public specifV11DataTypesIdRevisionsGet(id: SpecifId, options?: any) {
        return DataTypeApiFp(this.configuration).specifV11DataTypesIdRevisionsGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create the data type; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
     * @param {SpecifDataType} [body] The data type to create; the supplied ID must not exist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public specifV11DataTypesPost(body?: SpecifDataType, options?: any) {
        return DataTypeApiFp(this.configuration).specifV11DataTypesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the data type.
     * @param {SpecifDataType} [body] The data type to update; the supplied ID must exist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataTypeApi
     */
    public specifV11DataTypesPut(body?: SpecifDataType, options?: any) {
        return DataTypeApiFp(this.configuration).specifV11DataTypesPut(body, options)(this.fetch, this.basePath);
    }

}
/**
 * FileApi - fetch parameter creator
 * @export
 */
export const FileApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all files.
         * @param {SpecifId} [projectID] An optional project ID as filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesGet(projectID?: SpecifId, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/files`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (projectID !== undefined) {
                localVarQueryParameter['projectID'] = projectID;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the file descriptor; returns an error if there are referencing elements.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesIdDelete(id: SpecifId, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11FilesIdDelete.');
            }
            const localVarPath = `/specif/v1.1/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the file descriptor.
         * @param {SpecifId} id 
         * @param {SpecifRevision} [revision] The file descriptor revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesIdGet(id: SpecifId, revision?: SpecifRevision, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11FilesIdGet.');
            }
            const localVarPath = `/specif/v1.1/files/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (revision !== undefined) {
                localVarQueryParameter['revision'] = revision;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all revisions of the file descriptor.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesIdRevisionsGet(id: SpecifId, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11FilesIdRevisionsGet.');
            }
            const localVarPath = `/specif/v1.1/files/{id}/revisions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create the file descriptor; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesPost(file?: Blob, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/files`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the file descriptor.
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesPut(file?: Blob, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/files`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all files.
         * @param {SpecifId} [projectID] An optional project ID as filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesGet(projectID?: SpecifId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifFile>> {
            const localVarFetchArgs = FileApiFetchParamCreator(configuration).specifV11FilesGet(projectID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the file descriptor; returns an error if there are referencing elements.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesIdDelete(id: SpecifId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FileApiFetchParamCreator(configuration).specifV11FilesIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the file descriptor.
         * @param {SpecifId} id 
         * @param {SpecifRevision} [revision] The file descriptor revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpecifFile> {
            const localVarFetchArgs = FileApiFetchParamCreator(configuration).specifV11FilesIdGet(id, revision, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all revisions of the file descriptor.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesIdRevisionsGet(id: SpecifId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifFile>> {
            const localVarFetchArgs = FileApiFetchParamCreator(configuration).specifV11FilesIdRevisionsGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create the file descriptor; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesPost(file?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FileApiFetchParamCreator(configuration).specifV11FilesPost(file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the file descriptor.
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesPut(file?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FileApiFetchParamCreator(configuration).specifV11FilesPut(file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get all files.
         * @param {SpecifId} [projectID] An optional project ID as filter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesGet(projectID?: SpecifId, options?: any) {
            return FileApiFp(configuration).specifV11FilesGet(projectID, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the file descriptor; returns an error if there are referencing elements.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesIdDelete(id: SpecifId, options?: any) {
            return FileApiFp(configuration).specifV11FilesIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the file descriptor.
         * @param {SpecifId} id 
         * @param {SpecifRevision} [revision] The file descriptor revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any) {
            return FileApiFp(configuration).specifV11FilesIdGet(id, revision, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all revisions of the file descriptor.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesIdRevisionsGet(id: SpecifId, options?: any) {
            return FileApiFp(configuration).specifV11FilesIdRevisionsGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create the file descriptor; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesPost(file?: Blob, options?: any) {
            return FileApiFp(configuration).specifV11FilesPost(file, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the file descriptor.
         * @param {Blob} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11FilesPut(file?: Blob, options?: any) {
            return FileApiFp(configuration).specifV11FilesPut(file, options)(fetch, basePath);
        },
    };
};

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * 
     * @summary Get all files.
     * @param {SpecifId} [projectID] An optional project ID as filter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public specifV11FilesGet(projectID?: SpecifId, options?: any) {
        return FileApiFp(this.configuration).specifV11FilesGet(projectID, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the file descriptor; returns an error if there are referencing elements.
     * @param {SpecifId} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public specifV11FilesIdDelete(id: SpecifId, options?: any) {
        return FileApiFp(this.configuration).specifV11FilesIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the file descriptor.
     * @param {SpecifId} id 
     * @param {SpecifRevision} [revision] The file descriptor revision; if missing the newest is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public specifV11FilesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any) {
        return FileApiFp(this.configuration).specifV11FilesIdGet(id, revision, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all revisions of the file descriptor.
     * @param {SpecifId} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public specifV11FilesIdRevisionsGet(id: SpecifId, options?: any) {
        return FileApiFp(this.configuration).specifV11FilesIdRevisionsGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create the file descriptor; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public specifV11FilesPost(file?: Blob, options?: any) {
        return FileApiFp(this.configuration).specifV11FilesPost(file, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the file descriptor.
     * @param {Blob} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public specifV11FilesPut(file?: Blob, options?: any) {
        return FileApiFp(this.configuration).specifV11FilesPut(file, options)(this.fetch, this.basePath);
    }

}
/**
 * HierarchyApi - fetch parameter creator
 * @export
 */
export const HierarchyApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all hierarchies.
         * @param {string} [project] 
         * @param {boolean} [rootNodesOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesGet(project?: string, rootNodesOnly?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/hierarchies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (project !== undefined) {
                localVarQueryParameter['project'] = project;
            }

            if (rootNodesOnly !== undefined) {
                localVarQueryParameter['rootNodesOnly'] = rootNodesOnly;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the hierarchy node with the sub-tree.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesIdDelete(id: SpecifId, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11HierarchiesIdDelete.');
            }
            const localVarPath = `/specif/v1.1/hierarchies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the hierarchy node.
         * @param {SpecifId} id The hierarchy ID.
         * @param {SpecifRevision} [revision] The hierarchy revision.
         * @param {SpecifHierarchyDepth} [depth] The maximum depth of child nodes to return. If missing the complete hierarchy depth is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesIdGet(id: SpecifId, revision?: SpecifRevision, depth?: SpecifHierarchyDepth, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11HierarchiesIdGet.');
            }
            const localVarPath = `/specif/v1.1/hierarchies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (revision !== undefined) {
                localVarQueryParameter['revision'] = revision;
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all revisions of the hierarchy node including sub-tree.
         * @param {SpecifId} id The hierarchy ID.
         * @param {SpecifHierarchyDepth} [depth] The maximum depth of child nodes to return. If not set the complete hierarchy depth is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesIdRevisionsGet(id: SpecifId, depth?: SpecifHierarchyDepth, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11HierarchiesIdRevisionsGet.');
            }
            const localVarPath = `/specif/v1.1/hierarchies/{id}/revisions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create the hierarchy (sub-tree) with supplied nodes; the supplied ID must be unique. If no ID is supplied, it is created before insertion. Query ?parent=nodeId - the sub-tree will be inserted as first child. Query ?predecessor=nodeId - the sub-tree will be inserted after the specified node. Without query, the node (sub-tree) is inserted as first element at root level.
         * @param {SpecifNode} [body] The hierarchy to create.
         * @param {string} [parent] An optional parent node ID. The sub-tree will be inserted as first child.
         * @param {string} [predecessor] An optional predecessor node ID. The sub-tree will be inserted after the specified node.
         * @param {string} [projectId] The project ID. If the ID is given, the new hierarchy will be added to the specific project. Only useful for new hierarchies - no parent or predecessor given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesPost(body?: SpecifNode, parent?: string, predecessor?: string, projectId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/hierarchies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            if (predecessor !== undefined) {
                localVarQueryParameter['predecessor'] = predecessor;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecifNode" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates the hierarchy node. The supplied ID must exist somewhere in any hierarchy. Query ?parent=nodeId - the sub-tree will be moved and inserted as first child. Query ?predecessor=nodeId - the sub-tree will be moved and inserted after the specified node. Without query string, the node (sub-tree) is not moved.
         * @param {SpecifNode} [body] The hierarchy node to update; the supplied ID must exist.
         * @param {string} [parent] An optional parent node ID. The sub-tree will be inserted as first child.
         * @param {string} [predecessor] An optional predecessor node ID. The sub-tree will be inserted after the specified node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesPut(body?: SpecifNode, parent?: string, predecessor?: string, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/hierarchies`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            if (predecessor !== undefined) {
                localVarQueryParameter['predecessor'] = predecessor;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecifNode" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HierarchyApi - functional programming interface
 * @export
 */
export const HierarchyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all hierarchies.
         * @param {string} [project] 
         * @param {boolean} [rootNodesOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesGet(project?: string, rootNodesOnly?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifNodes>> {
            const localVarFetchArgs = HierarchyApiFetchParamCreator(configuration).specifV11HierarchiesGet(project, rootNodesOnly, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the hierarchy node with the sub-tree.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesIdDelete(id: SpecifId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HierarchyApiFetchParamCreator(configuration).specifV11HierarchiesIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the hierarchy node.
         * @param {SpecifId} id The hierarchy ID.
         * @param {SpecifRevision} [revision] The hierarchy revision.
         * @param {SpecifHierarchyDepth} [depth] The maximum depth of child nodes to return. If missing the complete hierarchy depth is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesIdGet(id: SpecifId, revision?: SpecifRevision, depth?: SpecifHierarchyDepth, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpecifNode> {
            const localVarFetchArgs = HierarchyApiFetchParamCreator(configuration).specifV11HierarchiesIdGet(id, revision, depth, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all revisions of the hierarchy node including sub-tree.
         * @param {SpecifId} id The hierarchy ID.
         * @param {SpecifHierarchyDepth} [depth] The maximum depth of child nodes to return. If not set the complete hierarchy depth is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesIdRevisionsGet(id: SpecifId, depth?: SpecifHierarchyDepth, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifNode>> {
            const localVarFetchArgs = HierarchyApiFetchParamCreator(configuration).specifV11HierarchiesIdRevisionsGet(id, depth, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create the hierarchy (sub-tree) with supplied nodes; the supplied ID must be unique. If no ID is supplied, it is created before insertion. Query ?parent=nodeId - the sub-tree will be inserted as first child. Query ?predecessor=nodeId - the sub-tree will be inserted after the specified node. Without query, the node (sub-tree) is inserted as first element at root level.
         * @param {SpecifNode} [body] The hierarchy to create.
         * @param {string} [parent] An optional parent node ID. The sub-tree will be inserted as first child.
         * @param {string} [predecessor] An optional predecessor node ID. The sub-tree will be inserted after the specified node.
         * @param {string} [projectId] The project ID. If the ID is given, the new hierarchy will be added to the specific project. Only useful for new hierarchies - no parent or predecessor given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesPost(body?: SpecifNode, parent?: string, predecessor?: string, projectId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HierarchyApiFetchParamCreator(configuration).specifV11HierarchiesPost(body, parent, predecessor, projectId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates the hierarchy node. The supplied ID must exist somewhere in any hierarchy. Query ?parent=nodeId - the sub-tree will be moved and inserted as first child. Query ?predecessor=nodeId - the sub-tree will be moved and inserted after the specified node. Without query string, the node (sub-tree) is not moved.
         * @param {SpecifNode} [body] The hierarchy node to update; the supplied ID must exist.
         * @param {string} [parent] An optional parent node ID. The sub-tree will be inserted as first child.
         * @param {string} [predecessor] An optional predecessor node ID. The sub-tree will be inserted after the specified node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesPut(body?: SpecifNode, parent?: string, predecessor?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = HierarchyApiFetchParamCreator(configuration).specifV11HierarchiesPut(body, parent, predecessor, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HierarchyApi - factory interface
 * @export
 */
export const HierarchyApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get all hierarchies.
         * @param {string} [project] 
         * @param {boolean} [rootNodesOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesGet(project?: string, rootNodesOnly?: boolean, options?: any) {
            return HierarchyApiFp(configuration).specifV11HierarchiesGet(project, rootNodesOnly, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the hierarchy node with the sub-tree.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesIdDelete(id: SpecifId, options?: any) {
            return HierarchyApiFp(configuration).specifV11HierarchiesIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the hierarchy node.
         * @param {SpecifId} id The hierarchy ID.
         * @param {SpecifRevision} [revision] The hierarchy revision.
         * @param {SpecifHierarchyDepth} [depth] The maximum depth of child nodes to return. If missing the complete hierarchy depth is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesIdGet(id: SpecifId, revision?: SpecifRevision, depth?: SpecifHierarchyDepth, options?: any) {
            return HierarchyApiFp(configuration).specifV11HierarchiesIdGet(id, revision, depth, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all revisions of the hierarchy node including sub-tree.
         * @param {SpecifId} id The hierarchy ID.
         * @param {SpecifHierarchyDepth} [depth] The maximum depth of child nodes to return. If not set the complete hierarchy depth is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesIdRevisionsGet(id: SpecifId, depth?: SpecifHierarchyDepth, options?: any) {
            return HierarchyApiFp(configuration).specifV11HierarchiesIdRevisionsGet(id, depth, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create the hierarchy (sub-tree) with supplied nodes; the supplied ID must be unique. If no ID is supplied, it is created before insertion. Query ?parent=nodeId - the sub-tree will be inserted as first child. Query ?predecessor=nodeId - the sub-tree will be inserted after the specified node. Without query, the node (sub-tree) is inserted as first element at root level.
         * @param {SpecifNode} [body] The hierarchy to create.
         * @param {string} [parent] An optional parent node ID. The sub-tree will be inserted as first child.
         * @param {string} [predecessor] An optional predecessor node ID. The sub-tree will be inserted after the specified node.
         * @param {string} [projectId] The project ID. If the ID is given, the new hierarchy will be added to the specific project. Only useful for new hierarchies - no parent or predecessor given.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesPost(body?: SpecifNode, parent?: string, predecessor?: string, projectId?: string, options?: any) {
            return HierarchyApiFp(configuration).specifV11HierarchiesPost(body, parent, predecessor, projectId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates the hierarchy node. The supplied ID must exist somewhere in any hierarchy. Query ?parent=nodeId - the sub-tree will be moved and inserted as first child. Query ?predecessor=nodeId - the sub-tree will be moved and inserted after the specified node. Without query string, the node (sub-tree) is not moved.
         * @param {SpecifNode} [body] The hierarchy node to update; the supplied ID must exist.
         * @param {string} [parent] An optional parent node ID. The sub-tree will be inserted as first child.
         * @param {string} [predecessor] An optional predecessor node ID. The sub-tree will be inserted after the specified node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11HierarchiesPut(body?: SpecifNode, parent?: string, predecessor?: string, options?: any) {
            return HierarchyApiFp(configuration).specifV11HierarchiesPut(body, parent, predecessor, options)(fetch, basePath);
        },
    };
};

/**
 * HierarchyApi - object-oriented interface
 * @export
 * @class HierarchyApi
 * @extends {BaseAPI}
 */
export class HierarchyApi extends BaseAPI {
    /**
     * 
     * @summary Get all hierarchies.
     * @param {string} [project] 
     * @param {boolean} [rootNodesOnly] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HierarchyApi
     */
    public specifV11HierarchiesGet(project?: string, rootNodesOnly?: boolean, options?: any) {
        return HierarchyApiFp(this.configuration).specifV11HierarchiesGet(project, rootNodesOnly, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the hierarchy node with the sub-tree.
     * @param {SpecifId} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HierarchyApi
     */
    public specifV11HierarchiesIdDelete(id: SpecifId, options?: any) {
        return HierarchyApiFp(this.configuration).specifV11HierarchiesIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the hierarchy node.
     * @param {SpecifId} id The hierarchy ID.
     * @param {SpecifRevision} [revision] The hierarchy revision.
     * @param {SpecifHierarchyDepth} [depth] The maximum depth of child nodes to return. If missing the complete hierarchy depth is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HierarchyApi
     */
    public specifV11HierarchiesIdGet(id: SpecifId, revision?: SpecifRevision, depth?: SpecifHierarchyDepth, options?: any) {
        return HierarchyApiFp(this.configuration).specifV11HierarchiesIdGet(id, revision, depth, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all revisions of the hierarchy node including sub-tree.
     * @param {SpecifId} id The hierarchy ID.
     * @param {SpecifHierarchyDepth} [depth] The maximum depth of child nodes to return. If not set the complete hierarchy depth is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HierarchyApi
     */
    public specifV11HierarchiesIdRevisionsGet(id: SpecifId, depth?: SpecifHierarchyDepth, options?: any) {
        return HierarchyApiFp(this.configuration).specifV11HierarchiesIdRevisionsGet(id, depth, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create the hierarchy (sub-tree) with supplied nodes; the supplied ID must be unique. If no ID is supplied, it is created before insertion. Query ?parent=nodeId - the sub-tree will be inserted as first child. Query ?predecessor=nodeId - the sub-tree will be inserted after the specified node. Without query, the node (sub-tree) is inserted as first element at root level.
     * @param {SpecifNode} [body] The hierarchy to create.
     * @param {string} [parent] An optional parent node ID. The sub-tree will be inserted as first child.
     * @param {string} [predecessor] An optional predecessor node ID. The sub-tree will be inserted after the specified node.
     * @param {string} [projectId] The project ID. If the ID is given, the new hierarchy will be added to the specific project. Only useful for new hierarchies - no parent or predecessor given.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HierarchyApi
     */
    public specifV11HierarchiesPost(body?: SpecifNode, parent?: string, predecessor?: string, projectId?: string, options?: any) {
        return HierarchyApiFp(this.configuration).specifV11HierarchiesPost(body, parent, predecessor, projectId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates the hierarchy node. The supplied ID must exist somewhere in any hierarchy. Query ?parent=nodeId - the sub-tree will be moved and inserted as first child. Query ?predecessor=nodeId - the sub-tree will be moved and inserted after the specified node. Without query string, the node (sub-tree) is not moved.
     * @param {SpecifNode} [body] The hierarchy node to update; the supplied ID must exist.
     * @param {string} [parent] An optional parent node ID. The sub-tree will be inserted as first child.
     * @param {string} [predecessor] An optional predecessor node ID. The sub-tree will be inserted after the specified node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HierarchyApi
     */
    public specifV11HierarchiesPut(body?: SpecifNode, parent?: string, predecessor?: string, options?: any) {
        return HierarchyApiFp(this.configuration).specifV11HierarchiesPut(body, parent, predecessor, options)(this.fetch, this.basePath);
    }

}
/**
 * ProjectApi - fetch parameter creator
 * @export
 */
export const ProjectApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all projects; to limit the size only root properties are delivered.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ProjectsGet(options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/projects`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the project.
         * @param {SpecifId} id The ID of the project to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ProjectsIdDelete(id: SpecifId, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11ProjectsIdDelete.');
            }
            const localVarPath = `/specif/v1.1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the project.
         * @param {SpecifId} id The project ID.
         * @param {SpecifKeys} [hierarchies] An optional comma seperated list of hierarchy root node IDs to limit the output of selected hierarchies.
         * @param {boolean} [includeMetadata] Set to true if the metadata should be included (e.g. resource classes etc.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ProjectsIdGet(id: SpecifId, hierarchies?: SpecifKeys, includeMetadata?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11ProjectsIdGet.');
            }
            const localVarPath = `/specif/v1.1/projects/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (hierarchies !== undefined) {
                localVarQueryParameter['hierarchies'] = hierarchies;
            }

            if (includeMetadata !== undefined) {
                localVarQueryParameter['includeMetadata'] = includeMetadata;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create the project; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecIF} [body] The project to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ProjectsPost(body?: SpecIF, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/projects`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecIF" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the project.
         * @param {SpecIF} [body] The project to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ProjectsPut(body?: SpecIF, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/projects`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecIF" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectApi - functional programming interface
 * @export
 */
export const ProjectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all projects; to limit the size only root properties are delivered.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ProjectsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProjectDescriptor>> {
            const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).specifV11ProjectsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the project.
         * @param {SpecifId} id The ID of the project to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ProjectsIdDelete(id: SpecifId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).specifV11ProjectsIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the project.
         * @param {SpecifId} id The project ID.
         * @param {SpecifKeys} [hierarchies] An optional comma seperated list of hierarchy root node IDs to limit the output of selected hierarchies.
         * @param {boolean} [includeMetadata] Set to true if the metadata should be included (e.g. resource classes etc.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ProjectsIdGet(id: SpecifId, hierarchies?: SpecifKeys, includeMetadata?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpecIF> {
            const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).specifV11ProjectsIdGet(id, hierarchies, includeMetadata, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create the project; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecIF} [body] The project to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ProjectsPost(body?: SpecIF, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).specifV11ProjectsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the project.
         * @param {SpecIF} [body] The project to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ProjectsPut(body?: SpecIF, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProjectApiFetchParamCreator(configuration).specifV11ProjectsPut(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProjectApi - factory interface
 * @export
 */
export const ProjectApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get all projects; to limit the size only root properties are delivered.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ProjectsGet(options?: any) {
            return ProjectApiFp(configuration).specifV11ProjectsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the project.
         * @param {SpecifId} id The ID of the project to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ProjectsIdDelete(id: SpecifId, options?: any) {
            return ProjectApiFp(configuration).specifV11ProjectsIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the project.
         * @param {SpecifId} id The project ID.
         * @param {SpecifKeys} [hierarchies] An optional comma seperated list of hierarchy root node IDs to limit the output of selected hierarchies.
         * @param {boolean} [includeMetadata] Set to true if the metadata should be included (e.g. resource classes etc.)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ProjectsIdGet(id: SpecifId, hierarchies?: SpecifKeys, includeMetadata?: boolean, options?: any) {
            return ProjectApiFp(configuration).specifV11ProjectsIdGet(id, hierarchies, includeMetadata, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create the project; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecIF} [body] The project to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ProjectsPost(body?: SpecIF, options?: any) {
            return ProjectApiFp(configuration).specifV11ProjectsPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the project.
         * @param {SpecIF} [body] The project to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ProjectsPut(body?: SpecIF, options?: any) {
            return ProjectApiFp(configuration).specifV11ProjectsPut(body, options)(fetch, basePath);
        },
    };
};

/**
 * ProjectApi - object-oriented interface
 * @export
 * @class ProjectApi
 * @extends {BaseAPI}
 */
export class ProjectApi extends BaseAPI {
    /**
     * 
     * @summary Get all projects; to limit the size only root properties are delivered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public specifV11ProjectsGet(options?: any) {
        return ProjectApiFp(this.configuration).specifV11ProjectsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the project.
     * @param {SpecifId} id The ID of the project to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public specifV11ProjectsIdDelete(id: SpecifId, options?: any) {
        return ProjectApiFp(this.configuration).specifV11ProjectsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the project.
     * @param {SpecifId} id The project ID.
     * @param {SpecifKeys} [hierarchies] An optional comma seperated list of hierarchy root node IDs to limit the output of selected hierarchies.
     * @param {boolean} [includeMetadata] Set to true if the metadata should be included (e.g. resource classes etc.)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public specifV11ProjectsIdGet(id: SpecifId, hierarchies?: SpecifKeys, includeMetadata?: boolean, options?: any) {
        return ProjectApiFp(this.configuration).specifV11ProjectsIdGet(id, hierarchies, includeMetadata, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create the project; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
     * @param {SpecIF} [body] The project to create; the supplied ID must not exist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public specifV11ProjectsPost(body?: SpecIF, options?: any) {
        return ProjectApiFp(this.configuration).specifV11ProjectsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the project.
     * @param {SpecIF} [body] The project to update; the supplied ID must exist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectApi
     */
    public specifV11ProjectsPut(body?: SpecIF, options?: any) {
        return ProjectApiFp(this.configuration).specifV11ProjectsPut(body, options)(this.fetch, this.basePath);
    }

}
/**
 * PropertyClassApi - fetch parameter creator
 * @export
 */
export const PropertyClassApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all property classes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesGet(options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/propertyClasses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the property class; returns an error if there are referencing elements.
         * @param {SpecifId} id The property class ID.
         * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesIdDelete(id: SpecifId, forced?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11PropertyClassesIdDelete.');
            }
            const localVarPath = `/specif/v1.1/propertyClasses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (forced !== undefined) {
                localVarQueryParameter['forced'] = forced;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the property class.
         * @param {SpecifId} id The property class ID.
         * @param {SpecifRevision} [revision] The property class revsion; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesIdGet(id: SpecifId, revision?: SpecifRevision, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11PropertyClassesIdGet.');
            }
            const localVarPath = `/specif/v1.1/propertyClasses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (revision !== undefined) {
                localVarQueryParameter['revision'] = revision;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all revisions of the property class.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesIdRevisionsGet(id: SpecifId, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11PropertyClassesIdRevisionsGet.');
            }
            const localVarPath = `/specif/v1.1/propertyClasses/{id}/revisions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create the property class; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifPropertyClass} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesPost(body?: SpecifPropertyClass, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/propertyClasses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecifPropertyClass" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the property class; the supplied ID must exist.
         * @param {SpecifPropertyClass} [body] The property class to update; the supplied ID must exist.
         * @param {string} [dataTypeID] 
         * @param {string} [dataTypeRevision] 
         * @param {string} [dataTypeDataSourceServiceName] 
         * @param {string} [dataTypeDataSourceServiceAddress] 
         * @param {number} [dataTypeDataSourceServicePort] 
         * @param {string} [dataTypeDataSourceServiceDescription] 
         * @param {string} [dataTypeDataSourceServiceNativeAccess] 
         * @param {string} [dataTypeDataSourceServiceKind] 
         * @param {string} [dataTypeDataSourceIconURL] 
         * @param {string} [dataTypeDataSourceID] 
         * @param {boolean} [dataTypeDataSourceMetadataRead] 
         * @param {boolean} [dataTypeDataSourceMetadataWrite] 
         * @param {boolean} [dataTypeDataSourceDataRead] 
         * @param {boolean} [dataTypeDataSourceDataWrite] 
         * @param {Array<string>} [dataTypeDataSourceTags] 
         * @param {boolean} [multiple] 
         * @param {string} [format] 
         * @param {string} [unit] 
         * @param {Array<SpecifValue>} [values] 
         * @param {string} [title] 
         * @param {Array<SpecifMultiLanguageText>} [description] 
         * @param {string} [projectID] 
         * @param {Date} [changedAt] 
         * @param {string} [changedBy] 
         * @param {string} [id] 
         * @param {string} [iD] 
         * @param {string} [revision] 
         * @param {Array<string>} [replaces] 
         * @param {string} [dataSourceServiceName] 
         * @param {string} [dataSourceServiceAddress] 
         * @param {number} [dataSourceServicePort] 
         * @param {string} [dataSourceServiceDescription] 
         * @param {string} [dataSourceServiceNativeAccess] 
         * @param {string} [dataSourceServiceKind] 
         * @param {string} [dataSourceIconURL] 
         * @param {string} [dataSourceID] 
         * @param {boolean} [dataSourceMetadataRead] 
         * @param {boolean} [dataSourceMetadataWrite] 
         * @param {boolean} [dataSourceDataRead] 
         * @param {boolean} [dataSourceDataWrite] 
         * @param {Array<string>} [dataSourceTags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesPut(body?: SpecifPropertyClass, dataTypeID?: string, dataTypeRevision?: string, dataTypeDataSourceServiceName?: string, dataTypeDataSourceServiceAddress?: string, dataTypeDataSourceServicePort?: number, dataTypeDataSourceServiceDescription?: string, dataTypeDataSourceServiceNativeAccess?: string, dataTypeDataSourceServiceKind?: string, dataTypeDataSourceIconURL?: string, dataTypeDataSourceID?: string, dataTypeDataSourceMetadataRead?: boolean, dataTypeDataSourceMetadataWrite?: boolean, dataTypeDataSourceDataRead?: boolean, dataTypeDataSourceDataWrite?: boolean, dataTypeDataSourceTags?: Array<string>, multiple?: boolean, format?: string, unit?: string, values?: Array<SpecifValue>, title?: string, description?: Array<SpecifMultiLanguageText>, projectID?: string, changedAt?: Date, changedBy?: string, id?: string, iD?: string, revision?: string, replaces?: Array<string>, dataSourceServiceName?: string, dataSourceServiceAddress?: string, dataSourceServicePort?: number, dataSourceServiceDescription?: string, dataSourceServiceNativeAccess?: string, dataSourceServiceKind?: string, dataSourceIconURL?: string, dataSourceID?: string, dataSourceMetadataRead?: boolean, dataSourceMetadataWrite?: boolean, dataSourceDataRead?: boolean, dataSourceDataWrite?: boolean, dataSourceTags?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/propertyClasses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (dataTypeID !== undefined) {
                localVarQueryParameter['dataType.iD'] = dataTypeID;
            }

            if (dataTypeRevision !== undefined) {
                localVarQueryParameter['dataType.revision'] = dataTypeRevision;
            }

            if (dataTypeDataSourceServiceName !== undefined) {
                localVarQueryParameter['dataType.dataSource.serviceName'] = dataTypeDataSourceServiceName;
            }

            if (dataTypeDataSourceServiceAddress !== undefined) {
                localVarQueryParameter['dataType.dataSource.serviceAddress'] = dataTypeDataSourceServiceAddress;
            }

            if (dataTypeDataSourceServicePort !== undefined) {
                localVarQueryParameter['dataType.dataSource.servicePort'] = dataTypeDataSourceServicePort;
            }

            if (dataTypeDataSourceServiceDescription !== undefined) {
                localVarQueryParameter['dataType.dataSource.serviceDescription'] = dataTypeDataSourceServiceDescription;
            }

            if (dataTypeDataSourceServiceNativeAccess !== undefined) {
                localVarQueryParameter['dataType.dataSource.serviceNativeAccess'] = dataTypeDataSourceServiceNativeAccess;
            }

            if (dataTypeDataSourceServiceKind !== undefined) {
                localVarQueryParameter['dataType.dataSource.serviceKind'] = dataTypeDataSourceServiceKind;
            }

            if (dataTypeDataSourceIconURL !== undefined) {
                localVarQueryParameter['dataType.dataSource.iconURL'] = dataTypeDataSourceIconURL;
            }

            if (dataTypeDataSourceID !== undefined) {
                localVarQueryParameter['dataType.dataSource.iD'] = dataTypeDataSourceID;
            }

            if (dataTypeDataSourceMetadataRead !== undefined) {
                localVarQueryParameter['dataType.dataSource.metadataRead'] = dataTypeDataSourceMetadataRead;
            }

            if (dataTypeDataSourceMetadataWrite !== undefined) {
                localVarQueryParameter['dataType.dataSource.metadataWrite'] = dataTypeDataSourceMetadataWrite;
            }

            if (dataTypeDataSourceDataRead !== undefined) {
                localVarQueryParameter['dataType.dataSource.dataRead'] = dataTypeDataSourceDataRead;
            }

            if (dataTypeDataSourceDataWrite !== undefined) {
                localVarQueryParameter['dataType.dataSource.dataWrite'] = dataTypeDataSourceDataWrite;
            }

            if (dataTypeDataSourceTags) {
                localVarQueryParameter['dataType.dataSource.tags'] = dataTypeDataSourceTags;
            }

            if (multiple !== undefined) {
                localVarQueryParameter['multiple'] = multiple;
            }

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (unit !== undefined) {
                localVarQueryParameter['unit'] = unit;
            }

            if (values) {
                localVarQueryParameter['values'] = values;
            }

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (description) {
                localVarQueryParameter['description'] = description;
            }

            if (projectID !== undefined) {
                localVarQueryParameter['projectID'] = projectID;
            }

            if (changedAt !== undefined) {
                localVarQueryParameter['changedAt'] = (changedAt as any).toISOString();
            }

            if (changedBy !== undefined) {
                localVarQueryParameter['changedBy'] = changedBy;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (iD !== undefined) {
                localVarQueryParameter['iD'] = iD;
            }

            if (revision !== undefined) {
                localVarQueryParameter['revision'] = revision;
            }

            if (replaces) {
                localVarQueryParameter['replaces'] = replaces;
            }

            if (dataSourceServiceName !== undefined) {
                localVarQueryParameter['dataSource.serviceName'] = dataSourceServiceName;
            }

            if (dataSourceServiceAddress !== undefined) {
                localVarQueryParameter['dataSource.serviceAddress'] = dataSourceServiceAddress;
            }

            if (dataSourceServicePort !== undefined) {
                localVarQueryParameter['dataSource.servicePort'] = dataSourceServicePort;
            }

            if (dataSourceServiceDescription !== undefined) {
                localVarQueryParameter['dataSource.serviceDescription'] = dataSourceServiceDescription;
            }

            if (dataSourceServiceNativeAccess !== undefined) {
                localVarQueryParameter['dataSource.serviceNativeAccess'] = dataSourceServiceNativeAccess;
            }

            if (dataSourceServiceKind !== undefined) {
                localVarQueryParameter['dataSource.serviceKind'] = dataSourceServiceKind;
            }

            if (dataSourceIconURL !== undefined) {
                localVarQueryParameter['dataSource.iconURL'] = dataSourceIconURL;
            }

            if (dataSourceID !== undefined) {
                localVarQueryParameter['dataSource.iD'] = dataSourceID;
            }

            if (dataSourceMetadataRead !== undefined) {
                localVarQueryParameter['dataSource.metadataRead'] = dataSourceMetadataRead;
            }

            if (dataSourceMetadataWrite !== undefined) {
                localVarQueryParameter['dataSource.metadataWrite'] = dataSourceMetadataWrite;
            }

            if (dataSourceDataRead !== undefined) {
                localVarQueryParameter['dataSource.dataRead'] = dataSourceDataRead;
            }

            if (dataSourceDataWrite !== undefined) {
                localVarQueryParameter['dataSource.dataWrite'] = dataSourceDataWrite;
            }

            if (dataSourceTags) {
                localVarQueryParameter['dataSource.tags'] = dataSourceTags;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecifPropertyClass" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PropertyClassApi - functional programming interface
 * @export
 */
export const PropertyClassApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all property classes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifPropertyClass>> {
            const localVarFetchArgs = PropertyClassApiFetchParamCreator(configuration).specifV11PropertyClassesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the property class; returns an error if there are referencing elements.
         * @param {SpecifId} id The property class ID.
         * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesIdDelete(id: SpecifId, forced?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PropertyClassApiFetchParamCreator(configuration).specifV11PropertyClassesIdDelete(id, forced, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the property class.
         * @param {SpecifId} id The property class ID.
         * @param {SpecifRevision} [revision] The property class revsion; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpecifPropertyClass> {
            const localVarFetchArgs = PropertyClassApiFetchParamCreator(configuration).specifV11PropertyClassesIdGet(id, revision, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all revisions of the property class.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesIdRevisionsGet(id: SpecifId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifPropertyClass>> {
            const localVarFetchArgs = PropertyClassApiFetchParamCreator(configuration).specifV11PropertyClassesIdRevisionsGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create the property class; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifPropertyClass} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesPost(body?: SpecifPropertyClass, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PropertyClassApiFetchParamCreator(configuration).specifV11PropertyClassesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the property class; the supplied ID must exist.
         * @param {SpecifPropertyClass} [body] The property class to update; the supplied ID must exist.
         * @param {string} [dataTypeID] 
         * @param {string} [dataTypeRevision] 
         * @param {string} [dataTypeDataSourceServiceName] 
         * @param {string} [dataTypeDataSourceServiceAddress] 
         * @param {number} [dataTypeDataSourceServicePort] 
         * @param {string} [dataTypeDataSourceServiceDescription] 
         * @param {string} [dataTypeDataSourceServiceNativeAccess] 
         * @param {string} [dataTypeDataSourceServiceKind] 
         * @param {string} [dataTypeDataSourceIconURL] 
         * @param {string} [dataTypeDataSourceID] 
         * @param {boolean} [dataTypeDataSourceMetadataRead] 
         * @param {boolean} [dataTypeDataSourceMetadataWrite] 
         * @param {boolean} [dataTypeDataSourceDataRead] 
         * @param {boolean} [dataTypeDataSourceDataWrite] 
         * @param {Array<string>} [dataTypeDataSourceTags] 
         * @param {boolean} [multiple] 
         * @param {string} [format] 
         * @param {string} [unit] 
         * @param {Array<SpecifValue>} [values] 
         * @param {string} [title] 
         * @param {Array<SpecifMultiLanguageText>} [description] 
         * @param {string} [projectID] 
         * @param {Date} [changedAt] 
         * @param {string} [changedBy] 
         * @param {string} [id] 
         * @param {string} [iD] 
         * @param {string} [revision] 
         * @param {Array<string>} [replaces] 
         * @param {string} [dataSourceServiceName] 
         * @param {string} [dataSourceServiceAddress] 
         * @param {number} [dataSourceServicePort] 
         * @param {string} [dataSourceServiceDescription] 
         * @param {string} [dataSourceServiceNativeAccess] 
         * @param {string} [dataSourceServiceKind] 
         * @param {string} [dataSourceIconURL] 
         * @param {string} [dataSourceID] 
         * @param {boolean} [dataSourceMetadataRead] 
         * @param {boolean} [dataSourceMetadataWrite] 
         * @param {boolean} [dataSourceDataRead] 
         * @param {boolean} [dataSourceDataWrite] 
         * @param {Array<string>} [dataSourceTags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesPut(body?: SpecifPropertyClass, dataTypeID?: string, dataTypeRevision?: string, dataTypeDataSourceServiceName?: string, dataTypeDataSourceServiceAddress?: string, dataTypeDataSourceServicePort?: number, dataTypeDataSourceServiceDescription?: string, dataTypeDataSourceServiceNativeAccess?: string, dataTypeDataSourceServiceKind?: string, dataTypeDataSourceIconURL?: string, dataTypeDataSourceID?: string, dataTypeDataSourceMetadataRead?: boolean, dataTypeDataSourceMetadataWrite?: boolean, dataTypeDataSourceDataRead?: boolean, dataTypeDataSourceDataWrite?: boolean, dataTypeDataSourceTags?: Array<string>, multiple?: boolean, format?: string, unit?: string, values?: Array<SpecifValue>, title?: string, description?: Array<SpecifMultiLanguageText>, projectID?: string, changedAt?: Date, changedBy?: string, id?: string, iD?: string, revision?: string, replaces?: Array<string>, dataSourceServiceName?: string, dataSourceServiceAddress?: string, dataSourceServicePort?: number, dataSourceServiceDescription?: string, dataSourceServiceNativeAccess?: string, dataSourceServiceKind?: string, dataSourceIconURL?: string, dataSourceID?: string, dataSourceMetadataRead?: boolean, dataSourceMetadataWrite?: boolean, dataSourceDataRead?: boolean, dataSourceDataWrite?: boolean, dataSourceTags?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PropertyClassApiFetchParamCreator(configuration).specifV11PropertyClassesPut(body, dataTypeID, dataTypeRevision, dataTypeDataSourceServiceName, dataTypeDataSourceServiceAddress, dataTypeDataSourceServicePort, dataTypeDataSourceServiceDescription, dataTypeDataSourceServiceNativeAccess, dataTypeDataSourceServiceKind, dataTypeDataSourceIconURL, dataTypeDataSourceID, dataTypeDataSourceMetadataRead, dataTypeDataSourceMetadataWrite, dataTypeDataSourceDataRead, dataTypeDataSourceDataWrite, dataTypeDataSourceTags, multiple, format, unit, values, title, description, projectID, changedAt, changedBy, id, iD, revision, replaces, dataSourceServiceName, dataSourceServiceAddress, dataSourceServicePort, dataSourceServiceDescription, dataSourceServiceNativeAccess, dataSourceServiceKind, dataSourceIconURL, dataSourceID, dataSourceMetadataRead, dataSourceMetadataWrite, dataSourceDataRead, dataSourceDataWrite, dataSourceTags, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PropertyClassApi - factory interface
 * @export
 */
export const PropertyClassApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get all property classes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesGet(options?: any) {
            return PropertyClassApiFp(configuration).specifV11PropertyClassesGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the property class; returns an error if there are referencing elements.
         * @param {SpecifId} id The property class ID.
         * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesIdDelete(id: SpecifId, forced?: boolean, options?: any) {
            return PropertyClassApiFp(configuration).specifV11PropertyClassesIdDelete(id, forced, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the property class.
         * @param {SpecifId} id The property class ID.
         * @param {SpecifRevision} [revision] The property class revsion; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any) {
            return PropertyClassApiFp(configuration).specifV11PropertyClassesIdGet(id, revision, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all revisions of the property class.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesIdRevisionsGet(id: SpecifId, options?: any) {
            return PropertyClassApiFp(configuration).specifV11PropertyClassesIdRevisionsGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create the property class; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifPropertyClass} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesPost(body?: SpecifPropertyClass, options?: any) {
            return PropertyClassApiFp(configuration).specifV11PropertyClassesPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the property class; the supplied ID must exist.
         * @param {SpecifPropertyClass} [body] The property class to update; the supplied ID must exist.
         * @param {string} [dataTypeID] 
         * @param {string} [dataTypeRevision] 
         * @param {string} [dataTypeDataSourceServiceName] 
         * @param {string} [dataTypeDataSourceServiceAddress] 
         * @param {number} [dataTypeDataSourceServicePort] 
         * @param {string} [dataTypeDataSourceServiceDescription] 
         * @param {string} [dataTypeDataSourceServiceNativeAccess] 
         * @param {string} [dataTypeDataSourceServiceKind] 
         * @param {string} [dataTypeDataSourceIconURL] 
         * @param {string} [dataTypeDataSourceID] 
         * @param {boolean} [dataTypeDataSourceMetadataRead] 
         * @param {boolean} [dataTypeDataSourceMetadataWrite] 
         * @param {boolean} [dataTypeDataSourceDataRead] 
         * @param {boolean} [dataTypeDataSourceDataWrite] 
         * @param {Array<string>} [dataTypeDataSourceTags] 
         * @param {boolean} [multiple] 
         * @param {string} [format] 
         * @param {string} [unit] 
         * @param {Array<SpecifValue>} [values] 
         * @param {string} [title] 
         * @param {Array<SpecifMultiLanguageText>} [description] 
         * @param {string} [projectID] 
         * @param {Date} [changedAt] 
         * @param {string} [changedBy] 
         * @param {string} [id] 
         * @param {string} [iD] 
         * @param {string} [revision] 
         * @param {Array<string>} [replaces] 
         * @param {string} [dataSourceServiceName] 
         * @param {string} [dataSourceServiceAddress] 
         * @param {number} [dataSourceServicePort] 
         * @param {string} [dataSourceServiceDescription] 
         * @param {string} [dataSourceServiceNativeAccess] 
         * @param {string} [dataSourceServiceKind] 
         * @param {string} [dataSourceIconURL] 
         * @param {string} [dataSourceID] 
         * @param {boolean} [dataSourceMetadataRead] 
         * @param {boolean} [dataSourceMetadataWrite] 
         * @param {boolean} [dataSourceDataRead] 
         * @param {boolean} [dataSourceDataWrite] 
         * @param {Array<string>} [dataSourceTags] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11PropertyClassesPut(body?: SpecifPropertyClass, dataTypeID?: string, dataTypeRevision?: string, dataTypeDataSourceServiceName?: string, dataTypeDataSourceServiceAddress?: string, dataTypeDataSourceServicePort?: number, dataTypeDataSourceServiceDescription?: string, dataTypeDataSourceServiceNativeAccess?: string, dataTypeDataSourceServiceKind?: string, dataTypeDataSourceIconURL?: string, dataTypeDataSourceID?: string, dataTypeDataSourceMetadataRead?: boolean, dataTypeDataSourceMetadataWrite?: boolean, dataTypeDataSourceDataRead?: boolean, dataTypeDataSourceDataWrite?: boolean, dataTypeDataSourceTags?: Array<string>, multiple?: boolean, format?: string, unit?: string, values?: Array<SpecifValue>, title?: string, description?: Array<SpecifMultiLanguageText>, projectID?: string, changedAt?: Date, changedBy?: string, id?: string, iD?: string, revision?: string, replaces?: Array<string>, dataSourceServiceName?: string, dataSourceServiceAddress?: string, dataSourceServicePort?: number, dataSourceServiceDescription?: string, dataSourceServiceNativeAccess?: string, dataSourceServiceKind?: string, dataSourceIconURL?: string, dataSourceID?: string, dataSourceMetadataRead?: boolean, dataSourceMetadataWrite?: boolean, dataSourceDataRead?: boolean, dataSourceDataWrite?: boolean, dataSourceTags?: Array<string>, options?: any) {
            return PropertyClassApiFp(configuration).specifV11PropertyClassesPut(body, dataTypeID, dataTypeRevision, dataTypeDataSourceServiceName, dataTypeDataSourceServiceAddress, dataTypeDataSourceServicePort, dataTypeDataSourceServiceDescription, dataTypeDataSourceServiceNativeAccess, dataTypeDataSourceServiceKind, dataTypeDataSourceIconURL, dataTypeDataSourceID, dataTypeDataSourceMetadataRead, dataTypeDataSourceMetadataWrite, dataTypeDataSourceDataRead, dataTypeDataSourceDataWrite, dataTypeDataSourceTags, multiple, format, unit, values, title, description, projectID, changedAt, changedBy, id, iD, revision, replaces, dataSourceServiceName, dataSourceServiceAddress, dataSourceServicePort, dataSourceServiceDescription, dataSourceServiceNativeAccess, dataSourceServiceKind, dataSourceIconURL, dataSourceID, dataSourceMetadataRead, dataSourceMetadataWrite, dataSourceDataRead, dataSourceDataWrite, dataSourceTags, options)(fetch, basePath);
        },
    };
};

/**
 * PropertyClassApi - object-oriented interface
 * @export
 * @class PropertyClassApi
 * @extends {BaseAPI}
 */
export class PropertyClassApi extends BaseAPI {
    /**
     * 
     * @summary Get all property classes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyClassApi
     */
    public specifV11PropertyClassesGet(options?: any) {
        return PropertyClassApiFp(this.configuration).specifV11PropertyClassesGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the property class; returns an error if there are referencing elements.
     * @param {SpecifId} id The property class ID.
     * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyClassApi
     */
    public specifV11PropertyClassesIdDelete(id: SpecifId, forced?: boolean, options?: any) {
        return PropertyClassApiFp(this.configuration).specifV11PropertyClassesIdDelete(id, forced, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the property class.
     * @param {SpecifId} id The property class ID.
     * @param {SpecifRevision} [revision] The property class revsion; if missing the newest is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyClassApi
     */
    public specifV11PropertyClassesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any) {
        return PropertyClassApiFp(this.configuration).specifV11PropertyClassesIdGet(id, revision, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all revisions of the property class.
     * @param {SpecifId} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyClassApi
     */
    public specifV11PropertyClassesIdRevisionsGet(id: SpecifId, options?: any) {
        return PropertyClassApiFp(this.configuration).specifV11PropertyClassesIdRevisionsGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create the property class; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
     * @param {SpecifPropertyClass} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyClassApi
     */
    public specifV11PropertyClassesPost(body?: SpecifPropertyClass, options?: any) {
        return PropertyClassApiFp(this.configuration).specifV11PropertyClassesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the property class; the supplied ID must exist.
     * @param {SpecifPropertyClass} [body] The property class to update; the supplied ID must exist.
     * @param {string} [dataTypeID] 
     * @param {string} [dataTypeRevision] 
     * @param {string} [dataTypeDataSourceServiceName] 
     * @param {string} [dataTypeDataSourceServiceAddress] 
     * @param {number} [dataTypeDataSourceServicePort] 
     * @param {string} [dataTypeDataSourceServiceDescription] 
     * @param {string} [dataTypeDataSourceServiceNativeAccess] 
     * @param {string} [dataTypeDataSourceServiceKind] 
     * @param {string} [dataTypeDataSourceIconURL] 
     * @param {string} [dataTypeDataSourceID] 
     * @param {boolean} [dataTypeDataSourceMetadataRead] 
     * @param {boolean} [dataTypeDataSourceMetadataWrite] 
     * @param {boolean} [dataTypeDataSourceDataRead] 
     * @param {boolean} [dataTypeDataSourceDataWrite] 
     * @param {Array<string>} [dataTypeDataSourceTags] 
     * @param {boolean} [multiple] 
     * @param {string} [format] 
     * @param {string} [unit] 
     * @param {Array<SpecifValue>} [values] 
     * @param {string} [title] 
     * @param {Array<SpecifMultiLanguageText>} [description] 
     * @param {string} [projectID] 
     * @param {Date} [changedAt] 
     * @param {string} [changedBy] 
     * @param {string} [id] 
     * @param {string} [iD] 
     * @param {string} [revision] 
     * @param {Array<string>} [replaces] 
     * @param {string} [dataSourceServiceName] 
     * @param {string} [dataSourceServiceAddress] 
     * @param {number} [dataSourceServicePort] 
     * @param {string} [dataSourceServiceDescription] 
     * @param {string} [dataSourceServiceNativeAccess] 
     * @param {string} [dataSourceServiceKind] 
     * @param {string} [dataSourceIconURL] 
     * @param {string} [dataSourceID] 
     * @param {boolean} [dataSourceMetadataRead] 
     * @param {boolean} [dataSourceMetadataWrite] 
     * @param {boolean} [dataSourceDataRead] 
     * @param {boolean} [dataSourceDataWrite] 
     * @param {Array<string>} [dataSourceTags] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PropertyClassApi
     */
    public specifV11PropertyClassesPut(body?: SpecifPropertyClass, dataTypeID?: string, dataTypeRevision?: string, dataTypeDataSourceServiceName?: string, dataTypeDataSourceServiceAddress?: string, dataTypeDataSourceServicePort?: number, dataTypeDataSourceServiceDescription?: string, dataTypeDataSourceServiceNativeAccess?: string, dataTypeDataSourceServiceKind?: string, dataTypeDataSourceIconURL?: string, dataTypeDataSourceID?: string, dataTypeDataSourceMetadataRead?: boolean, dataTypeDataSourceMetadataWrite?: boolean, dataTypeDataSourceDataRead?: boolean, dataTypeDataSourceDataWrite?: boolean, dataTypeDataSourceTags?: Array<string>, multiple?: boolean, format?: string, unit?: string, values?: Array<SpecifValue>, title?: string, description?: Array<SpecifMultiLanguageText>, projectID?: string, changedAt?: Date, changedBy?: string, id?: string, iD?: string, revision?: string, replaces?: Array<string>, dataSourceServiceName?: string, dataSourceServiceAddress?: string, dataSourceServicePort?: number, dataSourceServiceDescription?: string, dataSourceServiceNativeAccess?: string, dataSourceServiceKind?: string, dataSourceIconURL?: string, dataSourceID?: string, dataSourceMetadataRead?: boolean, dataSourceMetadataWrite?: boolean, dataSourceDataRead?: boolean, dataSourceDataWrite?: boolean, dataSourceTags?: Array<string>, options?: any) {
        return PropertyClassApiFp(this.configuration).specifV11PropertyClassesPut(body, dataTypeID, dataTypeRevision, dataTypeDataSourceServiceName, dataTypeDataSourceServiceAddress, dataTypeDataSourceServicePort, dataTypeDataSourceServiceDescription, dataTypeDataSourceServiceNativeAccess, dataTypeDataSourceServiceKind, dataTypeDataSourceIconURL, dataTypeDataSourceID, dataTypeDataSourceMetadataRead, dataTypeDataSourceMetadataWrite, dataTypeDataSourceDataRead, dataTypeDataSourceDataWrite, dataTypeDataSourceTags, multiple, format, unit, values, title, description, projectID, changedAt, changedBy, id, iD, revision, replaces, dataSourceServiceName, dataSourceServiceAddress, dataSourceServicePort, dataSourceServiceDescription, dataSourceServiceNativeAccess, dataSourceServiceKind, dataSourceIconURL, dataSourceID, dataSourceMetadataRead, dataSourceMetadataWrite, dataSourceDataRead, dataSourceDataWrite, dataSourceTags, options)(this.fetch, this.basePath);
    }

}
/**
 * ResourceApi - fetch parameter creator
 * @export
 */
export const ResourceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all resources.
         * @param {string} [projectID] An optional project ID. The endpoint then returns only resources for the given project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesGet(projectID?: string, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/resources`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (projectID !== undefined) {
                localVarQueryParameter['projectID'] = projectID;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the resource; returns an error if there are referencing elements.
         * @param {SpecifId} id The resource ID.
         * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesIdDelete(id: SpecifId, forced?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11ResourcesIdDelete.');
            }
            const localVarPath = `/specif/v1.1/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (forced !== undefined) {
                localVarQueryParameter['forced'] = forced;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the resource.
         * @param {SpecifId} id The resource ID.
         * @param {SpecifRevision} [revision] The resource revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesIdGet(id: SpecifId, revision?: SpecifRevision, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11ResourcesIdGet.');
            }
            const localVarPath = `/specif/v1.1/resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (revision !== undefined) {
                localVarQueryParameter['revision'] = revision;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all revisions of the resource.
         * @param {SpecifId} id The resource ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesIdRevisionsGet(id: SpecifId, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11ResourcesIdRevisionsGet.');
            }
            const localVarPath = `/specif/v1.1/resources/{id}/revisions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create the resource; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifResource} [body] The resource to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesPost(body?: SpecifResource, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/resources`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecifResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the resource.
         * @param {SpecifResource} [body] The resource to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesPut(body?: SpecifResource, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/resources`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecifResource" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceApi - functional programming interface
 * @export
 */
export const ResourceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all resources.
         * @param {string} [projectID] An optional project ID. The endpoint then returns only resources for the given project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesGet(projectID?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifResource>> {
            const localVarFetchArgs = ResourceApiFetchParamCreator(configuration).specifV11ResourcesGet(projectID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the resource; returns an error if there are referencing elements.
         * @param {SpecifId} id The resource ID.
         * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesIdDelete(id: SpecifId, forced?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ResourceApiFetchParamCreator(configuration).specifV11ResourcesIdDelete(id, forced, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the resource.
         * @param {SpecifId} id The resource ID.
         * @param {SpecifRevision} [revision] The resource revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpecifResource> {
            const localVarFetchArgs = ResourceApiFetchParamCreator(configuration).specifV11ResourcesIdGet(id, revision, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all revisions of the resource.
         * @param {SpecifId} id The resource ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesIdRevisionsGet(id: SpecifId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifResource>> {
            const localVarFetchArgs = ResourceApiFetchParamCreator(configuration).specifV11ResourcesIdRevisionsGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create the resource; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifResource} [body] The resource to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesPost(body?: SpecifResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ResourceApiFetchParamCreator(configuration).specifV11ResourcesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the resource.
         * @param {SpecifResource} [body] The resource to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesPut(body?: SpecifResource, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ResourceApiFetchParamCreator(configuration).specifV11ResourcesPut(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ResourceApi - factory interface
 * @export
 */
export const ResourceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get all resources.
         * @param {string} [projectID] An optional project ID. The endpoint then returns only resources for the given project.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesGet(projectID?: string, options?: any) {
            return ResourceApiFp(configuration).specifV11ResourcesGet(projectID, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the resource; returns an error if there are referencing elements.
         * @param {SpecifId} id The resource ID.
         * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesIdDelete(id: SpecifId, forced?: boolean, options?: any) {
            return ResourceApiFp(configuration).specifV11ResourcesIdDelete(id, forced, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the resource.
         * @param {SpecifId} id The resource ID.
         * @param {SpecifRevision} [revision] The resource revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any) {
            return ResourceApiFp(configuration).specifV11ResourcesIdGet(id, revision, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all revisions of the resource.
         * @param {SpecifId} id The resource ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesIdRevisionsGet(id: SpecifId, options?: any) {
            return ResourceApiFp(configuration).specifV11ResourcesIdRevisionsGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create the resource; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifResource} [body] The resource to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesPost(body?: SpecifResource, options?: any) {
            return ResourceApiFp(configuration).specifV11ResourcesPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the resource.
         * @param {SpecifResource} [body] The resource to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourcesPut(body?: SpecifResource, options?: any) {
            return ResourceApiFp(configuration).specifV11ResourcesPut(body, options)(fetch, basePath);
        },
    };
};

/**
 * ResourceApi - object-oriented interface
 * @export
 * @class ResourceApi
 * @extends {BaseAPI}
 */
export class ResourceApi extends BaseAPI {
    /**
     * 
     * @summary Get all resources.
     * @param {string} [projectID] An optional project ID. The endpoint then returns only resources for the given project.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceApi
     */
    public specifV11ResourcesGet(projectID?: string, options?: any) {
        return ResourceApiFp(this.configuration).specifV11ResourcesGet(projectID, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the resource; returns an error if there are referencing elements.
     * @param {SpecifId} id The resource ID.
     * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceApi
     */
    public specifV11ResourcesIdDelete(id: SpecifId, forced?: boolean, options?: any) {
        return ResourceApiFp(this.configuration).specifV11ResourcesIdDelete(id, forced, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the resource.
     * @param {SpecifId} id The resource ID.
     * @param {SpecifRevision} [revision] The resource revision; if missing the newest is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceApi
     */
    public specifV11ResourcesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any) {
        return ResourceApiFp(this.configuration).specifV11ResourcesIdGet(id, revision, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all revisions of the resource.
     * @param {SpecifId} id The resource ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceApi
     */
    public specifV11ResourcesIdRevisionsGet(id: SpecifId, options?: any) {
        return ResourceApiFp(this.configuration).specifV11ResourcesIdRevisionsGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create the resource; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
     * @param {SpecifResource} [body] The resource to create; the supplied ID must not exist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceApi
     */
    public specifV11ResourcesPost(body?: SpecifResource, options?: any) {
        return ResourceApiFp(this.configuration).specifV11ResourcesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the resource.
     * @param {SpecifResource} [body] The resource to update; the supplied ID must exist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceApi
     */
    public specifV11ResourcesPut(body?: SpecifResource, options?: any) {
        return ResourceApiFp(this.configuration).specifV11ResourcesPut(body, options)(this.fetch, this.basePath);
    }

}
/**
 * ResourceClassApi - fetch parameter creator
 * @export
 */
export const ResourceClassApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns all resource classes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesGet(options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/resourceClasses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the resource class; returns an error if there are referencing elements.
         * @param {SpecifId} id 
         * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesIdDelete(id: SpecifId, forced?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11ResourceClassesIdDelete.');
            }
            const localVarPath = `/specif/v1.1/resourceClasses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (forced !== undefined) {
                localVarQueryParameter['forced'] = forced;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the resource class.
         * @param {SpecifId} id The resource class ID.
         * @param {SpecifRevision} [revision] The resource class revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesIdGet(id: SpecifId, revision?: SpecifRevision, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11ResourceClassesIdGet.');
            }
            const localVarPath = `/specif/v1.1/resourceClasses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (revision !== undefined) {
                localVarQueryParameter['revision'] = revision;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all revisions of the resource class.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesIdRevisionsGet(id: SpecifId, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11ResourceClassesIdRevisionsGet.');
            }
            const localVarPath = `/specif/v1.1/resourceClasses/{id}/revisions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create the resource class; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifResourceClass} [body] The resource class to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesPost(body?: SpecifResourceClass, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/resourceClasses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecifResourceClass" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the resource class.
         * @param {SpecifResourceClass} [body] The resource class to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesPut(body?: SpecifResourceClass, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/resourceClasses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecifResourceClass" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceClassApi - functional programming interface
 * @export
 */
export const ResourceClassApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns all resource classes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifResourceClass>> {
            const localVarFetchArgs = ResourceClassApiFetchParamCreator(configuration).specifV11ResourceClassesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the resource class; returns an error if there are referencing elements.
         * @param {SpecifId} id 
         * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesIdDelete(id: SpecifId, forced?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ResourceClassApiFetchParamCreator(configuration).specifV11ResourceClassesIdDelete(id, forced, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the resource class.
         * @param {SpecifId} id The resource class ID.
         * @param {SpecifRevision} [revision] The resource class revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpecifResourceClass> {
            const localVarFetchArgs = ResourceClassApiFetchParamCreator(configuration).specifV11ResourceClassesIdGet(id, revision, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all revisions of the resource class.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesIdRevisionsGet(id: SpecifId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifResourceClass>> {
            const localVarFetchArgs = ResourceClassApiFetchParamCreator(configuration).specifV11ResourceClassesIdRevisionsGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create the resource class; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifResourceClass} [body] The resource class to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesPost(body?: SpecifResourceClass, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ResourceClassApiFetchParamCreator(configuration).specifV11ResourceClassesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the resource class.
         * @param {SpecifResourceClass} [body] The resource class to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesPut(body?: SpecifResourceClass, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ResourceClassApiFetchParamCreator(configuration).specifV11ResourceClassesPut(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ResourceClassApi - factory interface
 * @export
 */
export const ResourceClassApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Returns all resource classes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesGet(options?: any) {
            return ResourceClassApiFp(configuration).specifV11ResourceClassesGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the resource class; returns an error if there are referencing elements.
         * @param {SpecifId} id 
         * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesIdDelete(id: SpecifId, forced?: boolean, options?: any) {
            return ResourceClassApiFp(configuration).specifV11ResourceClassesIdDelete(id, forced, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the resource class.
         * @param {SpecifId} id The resource class ID.
         * @param {SpecifRevision} [revision] The resource class revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any) {
            return ResourceClassApiFp(configuration).specifV11ResourceClassesIdGet(id, revision, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all revisions of the resource class.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesIdRevisionsGet(id: SpecifId, options?: any) {
            return ResourceClassApiFp(configuration).specifV11ResourceClassesIdRevisionsGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create the resource class; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifResourceClass} [body] The resource class to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesPost(body?: SpecifResourceClass, options?: any) {
            return ResourceClassApiFp(configuration).specifV11ResourceClassesPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the resource class.
         * @param {SpecifResourceClass} [body] The resource class to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11ResourceClassesPut(body?: SpecifResourceClass, options?: any) {
            return ResourceClassApiFp(configuration).specifV11ResourceClassesPut(body, options)(fetch, basePath);
        },
    };
};

/**
 * ResourceClassApi - object-oriented interface
 * @export
 * @class ResourceClassApi
 * @extends {BaseAPI}
 */
export class ResourceClassApi extends BaseAPI {
    /**
     * 
     * @summary Returns all resource classes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceClassApi
     */
    public specifV11ResourceClassesGet(options?: any) {
        return ResourceClassApiFp(this.configuration).specifV11ResourceClassesGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the resource class; returns an error if there are referencing elements.
     * @param {SpecifId} id 
     * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceClassApi
     */
    public specifV11ResourceClassesIdDelete(id: SpecifId, forced?: boolean, options?: any) {
        return ResourceClassApiFp(this.configuration).specifV11ResourceClassesIdDelete(id, forced, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the resource class.
     * @param {SpecifId} id The resource class ID.
     * @param {SpecifRevision} [revision] The resource class revision; if missing the newest is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceClassApi
     */
    public specifV11ResourceClassesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any) {
        return ResourceClassApiFp(this.configuration).specifV11ResourceClassesIdGet(id, revision, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all revisions of the resource class.
     * @param {SpecifId} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceClassApi
     */
    public specifV11ResourceClassesIdRevisionsGet(id: SpecifId, options?: any) {
        return ResourceClassApiFp(this.configuration).specifV11ResourceClassesIdRevisionsGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create the resource class; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
     * @param {SpecifResourceClass} [body] The resource class to create; the supplied ID must not exist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceClassApi
     */
    public specifV11ResourceClassesPost(body?: SpecifResourceClass, options?: any) {
        return ResourceClassApiFp(this.configuration).specifV11ResourceClassesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the resource class.
     * @param {SpecifResourceClass} [body] The resource class to update; the supplied ID must exist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceClassApi
     */
    public specifV11ResourceClassesPut(body?: SpecifResourceClass, options?: any) {
        return ResourceClassApiFp(this.configuration).specifV11ResourceClassesPut(body, options)(this.fetch, this.basePath);
    }

}
/**
 * StatementApi - fetch parameter creator
 * @export
 */
export const StatementApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all statements.
         * @param {string} [projectID] The optional project ID to filter statements by project.
         * @param {string} [subjectID] The optional subject ID to filter statements only sourcing the element with the given ID.
         * @param {string} [subjectRevision] An optional subject revision. Only useful together with subject ID.
         * @param {string} [objectID] The optional object ID to filter statements only targeting the element with the given ID.
         * @param {string} [objectRevision] An optional object revision. Only useful together with object ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsGet(projectID?: string, subjectID?: string, subjectRevision?: string, objectID?: string, objectRevision?: string, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/statements`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (projectID !== undefined) {
                localVarQueryParameter['projectID'] = projectID;
            }

            if (subjectID !== undefined) {
                localVarQueryParameter['subjectID'] = subjectID;
            }

            if (subjectRevision !== undefined) {
                localVarQueryParameter['subjectRevision'] = subjectRevision;
            }

            if (objectID !== undefined) {
                localVarQueryParameter['objectID'] = objectID;
            }

            if (objectRevision !== undefined) {
                localVarQueryParameter['objectRevision'] = objectRevision;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the statement.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsIdDelete(id: SpecifId, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11StatementsIdDelete.');
            }
            const localVarPath = `/specif/v1.1/statements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the statement.
         * @param {SpecifId} id The statement ID.
         * @param {SpecifRevision} [revision] The statement revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsIdGet(id: SpecifId, revision?: SpecifRevision, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11StatementsIdGet.');
            }
            const localVarPath = `/specif/v1.1/statements/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (revision !== undefined) {
                localVarQueryParameter['revision'] = revision;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all revisions of the statement.
         * @param {SpecifId} id The statement ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsIdRevisionsGet(id: SpecifId, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11StatementsIdRevisionsGet.');
            }
            const localVarPath = `/specif/v1.1/statements/{id}/revisions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create the statement; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifStatement} [body] The statement to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsPost(body?: SpecifStatement, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/statements`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecifStatement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the statement.
         * @param {SpecifStatement} [body] The statement to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsPut(body?: SpecifStatement, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/statements`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecifStatement" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatementApi - functional programming interface
 * @export
 */
export const StatementApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all statements.
         * @param {string} [projectID] The optional project ID to filter statements by project.
         * @param {string} [subjectID] The optional subject ID to filter statements only sourcing the element with the given ID.
         * @param {string} [subjectRevision] An optional subject revision. Only useful together with subject ID.
         * @param {string} [objectID] The optional object ID to filter statements only targeting the element with the given ID.
         * @param {string} [objectRevision] An optional object revision. Only useful together with object ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsGet(projectID?: string, subjectID?: string, subjectRevision?: string, objectID?: string, objectRevision?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifStatement>> {
            const localVarFetchArgs = StatementApiFetchParamCreator(configuration).specifV11StatementsGet(projectID, subjectID, subjectRevision, objectID, objectRevision, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the statement.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsIdDelete(id: SpecifId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StatementApiFetchParamCreator(configuration).specifV11StatementsIdDelete(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the statement.
         * @param {SpecifId} id The statement ID.
         * @param {SpecifRevision} [revision] The statement revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsIdGet(id: SpecifId, revision?: SpecifRevision, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<SpecifStatement> {
            const localVarFetchArgs = StatementApiFetchParamCreator(configuration).specifV11StatementsIdGet(id, revision, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all revisions of the statement.
         * @param {SpecifId} id The statement ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsIdRevisionsGet(id: SpecifId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifStatement>> {
            const localVarFetchArgs = StatementApiFetchParamCreator(configuration).specifV11StatementsIdRevisionsGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create the statement; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifStatement} [body] The statement to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsPost(body?: SpecifStatement, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StatementApiFetchParamCreator(configuration).specifV11StatementsPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the statement.
         * @param {SpecifStatement} [body] The statement to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsPut(body?: SpecifStatement, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StatementApiFetchParamCreator(configuration).specifV11StatementsPut(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StatementApi - factory interface
 * @export
 */
export const StatementApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get all statements.
         * @param {string} [projectID] The optional project ID to filter statements by project.
         * @param {string} [subjectID] The optional subject ID to filter statements only sourcing the element with the given ID.
         * @param {string} [subjectRevision] An optional subject revision. Only useful together with subject ID.
         * @param {string} [objectID] The optional object ID to filter statements only targeting the element with the given ID.
         * @param {string} [objectRevision] An optional object revision. Only useful together with object ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsGet(projectID?: string, subjectID?: string, subjectRevision?: string, objectID?: string, objectRevision?: string, options?: any) {
            return StatementApiFp(configuration).specifV11StatementsGet(projectID, subjectID, subjectRevision, objectID, objectRevision, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the statement.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsIdDelete(id: SpecifId, options?: any) {
            return StatementApiFp(configuration).specifV11StatementsIdDelete(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the statement.
         * @param {SpecifId} id The statement ID.
         * @param {SpecifRevision} [revision] The statement revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsIdGet(id: SpecifId, revision?: SpecifRevision, options?: any) {
            return StatementApiFp(configuration).specifV11StatementsIdGet(id, revision, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all revisions of the statement.
         * @param {SpecifId} id The statement ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsIdRevisionsGet(id: SpecifId, options?: any) {
            return StatementApiFp(configuration).specifV11StatementsIdRevisionsGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create the statement; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifStatement} [body] The statement to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsPost(body?: SpecifStatement, options?: any) {
            return StatementApiFp(configuration).specifV11StatementsPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the statement.
         * @param {SpecifStatement} [body] The statement to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementsPut(body?: SpecifStatement, options?: any) {
            return StatementApiFp(configuration).specifV11StatementsPut(body, options)(fetch, basePath);
        },
    };
};

/**
 * StatementApi - object-oriented interface
 * @export
 * @class StatementApi
 * @extends {BaseAPI}
 */
export class StatementApi extends BaseAPI {
    /**
     * 
     * @summary Get all statements.
     * @param {string} [projectID] The optional project ID to filter statements by project.
     * @param {string} [subjectID] The optional subject ID to filter statements only sourcing the element with the given ID.
     * @param {string} [subjectRevision] An optional subject revision. Only useful together with subject ID.
     * @param {string} [objectID] The optional object ID to filter statements only targeting the element with the given ID.
     * @param {string} [objectRevision] An optional object revision. Only useful together with object ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementApi
     */
    public specifV11StatementsGet(projectID?: string, subjectID?: string, subjectRevision?: string, objectID?: string, objectRevision?: string, options?: any) {
        return StatementApiFp(this.configuration).specifV11StatementsGet(projectID, subjectID, subjectRevision, objectID, objectRevision, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the statement.
     * @param {SpecifId} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementApi
     */
    public specifV11StatementsIdDelete(id: SpecifId, options?: any) {
        return StatementApiFp(this.configuration).specifV11StatementsIdDelete(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the statement.
     * @param {SpecifId} id The statement ID.
     * @param {SpecifRevision} [revision] The statement revision; if missing the newest is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementApi
     */
    public specifV11StatementsIdGet(id: SpecifId, revision?: SpecifRevision, options?: any) {
        return StatementApiFp(this.configuration).specifV11StatementsIdGet(id, revision, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all revisions of the statement.
     * @param {SpecifId} id The statement ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementApi
     */
    public specifV11StatementsIdRevisionsGet(id: SpecifId, options?: any) {
        return StatementApiFp(this.configuration).specifV11StatementsIdRevisionsGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create the statement; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
     * @param {SpecifStatement} [body] The statement to create; the supplied ID must not exist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementApi
     */
    public specifV11StatementsPost(body?: SpecifStatement, options?: any) {
        return StatementApiFp(this.configuration).specifV11StatementsPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the statement.
     * @param {SpecifStatement} [body] The statement to update; the supplied ID must exist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementApi
     */
    public specifV11StatementsPut(body?: SpecifStatement, options?: any) {
        return StatementApiFp(this.configuration).specifV11StatementsPut(body, options)(this.fetch, this.basePath);
    }

}
/**
 * StatementClassApi - fetch parameter creator
 * @export
 */
export const StatementClassApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all statement classes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesGet(options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/statementClasses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete the statement class; returns an error if there are referencing elements.
         * @param {SpecifId} id 
         * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesIdDelete(id: SpecifId, forced?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11StatementClassesIdDelete.');
            }
            const localVarPath = `/specif/v1.1/statementClasses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (forced !== undefined) {
                localVarQueryParameter['forced'] = forced;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the statement class.
         * @param {SpecifId} id The statement class ID.
         * @param {SpecifRevision} [revision] The statement class revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesIdGet(id: SpecifId, revision?: SpecifRevision, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11StatementClassesIdGet.');
            }
            const localVarPath = `/specif/v1.1/statementClasses/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            if (revision !== undefined) {
                localVarQueryParameter['revision'] = revision;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all revisions of the statement class.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesIdRevisionsGet(id: SpecifId, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling specifV11StatementClassesIdRevisionsGet.');
            }
            const localVarPath = `/specif/v1.1/statementClasses/{id}/revisions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create the statement class; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifStatementClass} [body] The statement class to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesPost(body?: SpecifStatementClass, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/statementClasses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecifStatementClass" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update the statement class.
         * @param {SpecifStatementClass} [body] The statement class to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesPut(body?: SpecifStatementClass, options: any = {}): FetchArgs {
            const localVarPath = `/specif/v1.1/statementClasses`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication X-API-KEY required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("X-API-KEY")
					: configuration.apiKey;
                localVarHeaderParameter["X-API-KEY"] = localVarApiKeyValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json-patch+json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SpecifStatementClass" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatementClassApi - functional programming interface
 * @export
 */
export const StatementClassApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all statement classes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifStatementClass>> {
            const localVarFetchArgs = StatementClassApiFetchParamCreator(configuration).specifV11StatementClassesGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Delete the statement class; returns an error if there are referencing elements.
         * @param {SpecifId} id 
         * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesIdDelete(id: SpecifId, forced?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StatementClassApiFetchParamCreator(configuration).specifV11StatementClassesIdDelete(id, forced, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the statement class.
         * @param {SpecifId} id The statement class ID.
         * @param {SpecifRevision} [revision] The statement class revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<StatementClass> {
            const localVarFetchArgs = StatementClassApiFetchParamCreator(configuration).specifV11StatementClassesIdGet(id, revision, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all revisions of the statement class.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesIdRevisionsGet(id: SpecifId, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SpecifStatementClass>> {
            const localVarFetchArgs = StatementClassApiFetchParamCreator(configuration).specifV11StatementClassesIdRevisionsGet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Create the statement class; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifStatementClass} [body] The statement class to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesPost(body?: SpecifStatementClass, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StatementClassApiFetchParamCreator(configuration).specifV11StatementClassesPost(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Update the statement class.
         * @param {SpecifStatementClass} [body] The statement class to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesPut(body?: SpecifStatementClass, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StatementClassApiFetchParamCreator(configuration).specifV11StatementClassesPut(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StatementClassApi - factory interface
 * @export
 */
export const StatementClassApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Get all statement classes.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesGet(options?: any) {
            return StatementClassApiFp(configuration).specifV11StatementClassesGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Delete the statement class; returns an error if there are referencing elements.
         * @param {SpecifId} id 
         * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesIdDelete(id: SpecifId, forced?: boolean, options?: any) {
            return StatementClassApiFp(configuration).specifV11StatementClassesIdDelete(id, forced, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the statement class.
         * @param {SpecifId} id The statement class ID.
         * @param {SpecifRevision} [revision] The statement class revision; if missing the newest is returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any) {
            return StatementClassApiFp(configuration).specifV11StatementClassesIdGet(id, revision, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all revisions of the statement class.
         * @param {SpecifId} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesIdRevisionsGet(id: SpecifId, options?: any) {
            return StatementClassApiFp(configuration).specifV11StatementClassesIdRevisionsGet(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Create the statement class; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
         * @param {SpecifStatementClass} [body] The statement class to create; the supplied ID must not exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesPost(body?: SpecifStatementClass, options?: any) {
            return StatementClassApiFp(configuration).specifV11StatementClassesPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update the statement class.
         * @param {SpecifStatementClass} [body] The statement class to update; the supplied ID must exist.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        specifV11StatementClassesPut(body?: SpecifStatementClass, options?: any) {
            return StatementClassApiFp(configuration).specifV11StatementClassesPut(body, options)(fetch, basePath);
        },
    };
};

/**
 * StatementClassApi - object-oriented interface
 * @export
 * @class StatementClassApi
 * @extends {BaseAPI}
 */
export class StatementClassApi extends BaseAPI {
    /**
     * 
     * @summary Get all statement classes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementClassApi
     */
    public specifV11StatementClassesGet(options?: any) {
        return StatementClassApiFp(this.configuration).specifV11StatementClassesGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Delete the statement class; returns an error if there are referencing elements.
     * @param {SpecifId} id 
     * @param {boolean} [forced] Query ?forced&#x3D;true results in deleting all directly and indirectly referencing elements.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementClassApi
     */
    public specifV11StatementClassesIdDelete(id: SpecifId, forced?: boolean, options?: any) {
        return StatementClassApiFp(this.configuration).specifV11StatementClassesIdDelete(id, forced, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the statement class.
     * @param {SpecifId} id The statement class ID.
     * @param {SpecifRevision} [revision] The statement class revision; if missing the newest is returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementClassApi
     */
    public specifV11StatementClassesIdGet(id: SpecifId, revision?: SpecifRevision, options?: any) {
        return StatementClassApiFp(this.configuration).specifV11StatementClassesIdGet(id, revision, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all revisions of the statement class.
     * @param {SpecifId} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementClassApi
     */
    public specifV11StatementClassesIdRevisionsGet(id: SpecifId, options?: any) {
        return StatementClassApiFp(this.configuration).specifV11StatementClassesIdRevisionsGet(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Create the statement class; the supplied ID must be unique. If no ID is supplied, it is created before insertion.
     * @param {SpecifStatementClass} [body] The statement class to create; the supplied ID must not exist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementClassApi
     */
    public specifV11StatementClassesPost(body?: SpecifStatementClass, options?: any) {
        return StatementClassApiFp(this.configuration).specifV11StatementClassesPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Update the statement class.
     * @param {SpecifStatementClass} [body] The statement class to update; the supplied ID must exist.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementClassApi
     */
    public specifV11StatementClassesPut(body?: SpecifStatementClass, options?: any) {
        return StatementClassApiFp(this.configuration).specifV11StatementClassesPut(body, options)(this.fetch, this.basePath);
    }

}
